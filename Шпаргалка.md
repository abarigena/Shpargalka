# Шпаргалка для собеседований по Java

## Содержание

1.  [Java Core](#java-core)
    *   [Основы и ООП](#основы-и-ооп)
    *   [Строки (String)](#строки-string)
    *   [Аннотации](#аннотации)
    *   [Generics (Обобщения)](#generics-обобщения)
    *   [Коллекции](#коллекции)
    *   [Исключения](#исключения)
    *   [Stream API](#stream-api)
    *   [Работа с памятью и GC](#работа-с-памятью-и-gc)
    *   [Рефлексия](#рефлексия)
    *   [Иммутабельность](#иммутабельность)
2.  [Concurrency (Многопоточность)](#concurrency-многопоточность)
    *   [Основы](#основы)
    *   [Синхронизация](#синхронизация)
    *   [Потокобезопасность (Thread Safety)](#потокобезопасность-thread-safety)
    *   [Deadlock (Взаимная блокировка)](#deadlock-взаимная-блокировка)
    *   [Executor Framework](#executor-framework)
    *   [java.util.concurrent](#javautilconcurrent)
    *   [ForkJoinPool](#forkjoinpool)
3.  [Базы данных и Persistence](#базы-данных-и-persistence)
    *   [Общие концепции БД](#общие-концепции-бд)
    *   [JDBC vs ORM/JPA](#jdbc-vs-ormjpa)
    *   [JPA/Hibernate](#jpahibernate)
    *   [Миграции (Liquibase)](#миграции-liquibase)
    *   [Безопасность (SQL Injection)](#безопасность-sql-injection)
4.  [Spring Framework](#spring-framework)
    *   [Основы Spring и Spring Boot](#основы-spring-и-spring-boot)
    *   [Spring Core (DI, IoC, Beans)](#spring-core-di-ioc-beans)
    *   [Spring Data](#spring-data)
    *   [Spring Web](#spring-web)
    *   [Spring AOP](#spring-aop)
    *   [Транзакции в Spring](#транзакции-в-spring)
    *   [Планировщик задач](#планировщик-задач)
    *   [Spring Security](#spring-security)
    *   [Spring Profiles](#spring-profiles)
5.  [Микросервисы и Распределенные системы](#микросервисы-и-распределенные-системы)
    *   [Архитектурные стили](#архитектурные-стили)
    *   [Коммуникация](#коммуникация)
    *   [Паттерны координации](#паттерны-координации)
    *   [Распределенные транзакции](#распределенные-транзакции)
    *   [API Gateway и Балансировка](#api-gateway-и-балансировка)
    *   [Messaging (Kafka)](#messaging-kafka)
    *   [Паттерны отказоустойчивости](#паттерны-отказоустойчивости)
    *   [Вспомогательные паттерны](#вспомогательные-паттерны)
6.  [Контейнеризация и Оркестрация](#контейнеризация-и-оркестрация)
    *   [Docker](#docker)
    *   [Kubernetes](#kubernetes)
7.  [Инструменты и Сборка](#инструменты-и-сборка)
    *   [Maven](#maven)
    *   [Git](#git)
    *   [CI/CD](#cicd)
8.  [Тестирование](#тестирование)
    *   [Модульное тестирование (Unit Testing)](#модульное-тестирование-unit-testing)
    *   [Интеграционное тестирование (Integration Testing)](#интеграционное-тестирование-integration-testing)
9.  [Принципы проектирования](#принципы-проектирования)
    *   [SOLID](#solid)
10. [Сетевые протоколы и Безопасность](#сетевые-протоколы-и-безопасность)
    *   [TLS (Transport Layer Security)](#tls-transport-layer-security)
    *   [HTTP](#http)
    *   [CORS (Cross-Origin Resource Sharing)](#cors-cross-origin-resource-sharing)
    *   [Веб-безопасность](#веб-безопасность)
    *   [Rate Limiter](#rate-limiter)
11. [Алгоритмы и Структуры данных](#алгоритмы-и-структуры-данных)
    *   [Временная сложность (Time Complexity)](#временная-сложность-time-complexity)

---

## Java Core

### Основы и ООП

*   **Примитивный тип vs Ссылочный:**
    *   **Примитивы:** Хранят значение непосредственно (int, boolean, char...). Обычно на стеке. Не могут быть `null`. Занимают фиксированный размер памяти.
    *   **Ссылочные:** Хранят адрес (ссылку) на объект в куче (heap). Объекты создаются через `new` (кроме строк). Могут быть `null`. Размер зависит от объекта.
*   **Методы класса Object:** Корневой класс для всех классов Java. Его методы доступны всем объектам:
    *   `equals(Object obj)`: Сравнение объектов на равенство (по умолчанию сравнивает ссылки).
    *   `hashCode()`: Возвращает хэш-код объекта (используется в хэш-коллекциях).
    *   `toString()`: Возвращает строковое представление объекта.
    *   `getClass()`: Возвращает объект `Class`, представляющий класс объекта во время выполнения.
    *   `clone()`: Создает копию объекта (требует реализации интерфейса `Cloneable`).
    *   `finalize()`: Вызывается сборщиком мусора перед удалением объекта (не рекомендуется использовать).
    *   `wait()`, `notify()`, `notifyAll()`: Для синхронизации потоков (связаны с монитором объекта).
*   **Переопределение equals() и hashCode():**
    *   **Контракт:** Если переопределяете `equals()`, **обязательно** нужно переопределить `hashCode()`.
    *   **Правило:** Если `a.equals(b)` возвращает `true`, то `a.hashCode()` *должен* быть равен `b.hashCode()`. Обратное не обязательно: если хэш-коды равны, объекты не обязательно равны (коллизия).
    *   **`equals()` контракт:** рефлексивность (`x.equals(x)`), симметричность (`x.equals(y)` <=> `y.equals(x)`), транзитивность (`x.equals(y)` и `y.equals(z)` => `x.equals(z)`), консистентность (повторный вызов дает тот же результат), сравнение с `null` всегда `false`.
*   **Абстрактные классы:**
    *   Класс с модификатором `abstract`. Нельзя создать экземпляр (`new`).
    *   Может содержать абстрактные методы (без реализации, `abstract void method();`) и обычные методы с реализацией, поля (в т.ч. с состоянием), конструкторы.
    *   Используется как базовый класс для наследования (`extends`). Класс может наследовать только *один* абстрактный класс.
*   **Интерфейсы:**
    *   Контракт, определяющий набор методов (до Java 8 - только абстрактных).
    *   Не может иметь полей состояния (только константы `public static final`). Нет конструкторов.
    *   Класс может реализовывать (`implements`) *множество* интерфейсов.
    *   С Java 8 могут содержать `default` (с реализацией) и `static` методы. С Java 9+ также `private` методы.
*   **Сравнение абстрактных классов и интерфейсов:**
    *   **Наследование:** Класс наследует 1 абстр. класс, реализует много интерфейсов.
    *   **Состояние:** Абстр. класс может иметь состояние (поля экземпляра), интерфейс - нет (только константы).
    *   **Конструкторы:** Абстр. класс может иметь, интерфейс - нет.
    *   **Методы:** Абстр. класс - любые, интерфейс - `abstract`, `default`, `static`, `private` (с Java 9+).
    *   **Цель:** Абстр. класс - основа иерархии с общей реализацией/состоянием ("is a" с общим кодом). Интерфейс - контракт поведения ("can do").
*   **Дефолтные методы в интерфейсах (Java 8+):** Позволяют добавлять новые методы в интерфейс с реализацией по умолчанию, не ломая существующие классы, реализующие этот интерфейс (обеспечивают обратную совместимость и эволюцию API).

### Строки (String)

*   **Иммутабельность (Immutability):** Объекты `String` неизменяемы. Любая операция, которая кажется модификацией строки (конкатенация `+`, `substring()`, `replace()`, `toLowerCase()`), на самом деле создает *новый* объект `String`.
    *   **Преимущества:** Потокобезопасность, возможность использования в качестве ключей `HashMap`, безопасность (нельзя изменить строку после передачи), кеширование (String Pool).
*   **String Pool (Пул строк):** Область в heap (ранее в PermGen/Metaspace), где хранятся уникальные строковые литералы и строки, добавленные через `intern()`. Позволяет экономить память, используя одну и ту же ссылку для одинаковых строк.
    *   `String s1 = "hello";`
    *   `String s2 = "hello";` // s1 == s2 вернет true (ссылки на один объект из пула)
    *   `String s3 = new String("hello");` // s1 == s3 вернет false (новый объект в heap)
    *   `String s4 = s3.intern();` // s1 == s4 вернет true (s4 ссылается на объект из пула)
*   **Сравнение строк:**
    *   `==`: Сравнивает **ссылки** на объекты. Используется для проверки, указывают ли переменные на один и тот же объект в памяти.
    *   `equals()`: Сравнивает **содержимое** строк (последовательность символов). **Правильный способ** сравнения строк на равенство значений.
*   **`StringBuilder` и `StringBuffer`:** Изменяемые последовательности символов. Используются, когда нужно многократно модифицировать строку (например, в циклах). `StringBuilder` не потокобезопасен (быстрее), `StringBuffer` потокобезопасен (методы `synchronized`).

### Аннотации

*   **Что такое:** Метаданные, добавляемые к коду (классам, методам, полям, параметрам...). Не меняют логику выполнения напрямую, но могут использоваться инструментами, фреймворками или компилятором для генерации кода, валидации, конфигурации и т.д.
*   **Как создать:** С помощью ключевого слова **`@interface`**.
    ```java
    // Определение аннотации
    @Retention(RetentionPolicy.RUNTIME) // Где будет доступна аннотация
    @Target(ElementType.METHOD) // К чему можно применять
    public @interface MyAnnotation {
        String value() default "default value"; // Элемент аннотации (как метод)
        int count() default 1;
    }

    // Использование аннотации
    public class MyClass {
        @MyAnnotation(value = "Example", count = 5)
        public void myMethod() {
            // ...
        }
    }
    ```
*   **Элементы аннотации:** Определяются как методы без параметров. Тип возвращаемого значения - тип элемента (примитивы, String, Class, enum, другая аннотация, массивы перечисленных типов). Могут иметь `default` значение.
*   **Мета-аннотации:** Аннотации, применяемые к другим аннотациям:
    *   `@Retention`: Определяет жизненный цикл аннотации (`SOURCE` - только в исходниках, `CLASS` - в .class файле, но недоступна в runtime, `RUNTIME` - доступна во время выполнения через рефлексию).
    *   `@Target`: Указывает, к каким элементам кода можно применять аннотацию (`TYPE`, `FIELD`, `METHOD`, `PARAMETER`, `CONSTRUCTOR`, `LOCAL_VARIABLE`, `ANNOTATION_TYPE`, `PACKAGE`, `TYPE_PARAMETER`, `TYPE_USE`).
    *   `@Inherited`: Указывает, что аннотация наследуется дочерними классами (только для аннотаций над классами).
    *   `@Documented`: Указывает, что аннотация должна быть включена в JavaDoc.
    *   `@Repeatable`: Позволяет применять одну и ту же аннотацию несколько раз к одному элементу.
*   **Обработка:** Часто обрабатываются во время компиляции (Annotation Processing Tool - APT) для генерации кода или во время выполнения (Reflection) фреймворками (Spring, Hibernate) для конфигурации и управления поведением.

### Generics (Обобщения)

*   **Что такое:** Параметризация типов. Позволяют создавать классы, интерфейсы и методы, работающие с типами, указанными при создании/вызове (например, `List<String>`, `Map<Integer, User>`).
*   **Преимущества:**
    *   **Типобезопасность:** Ошибки несоответствия типов обнаруживаются на этапе компиляции, а не в runtime (`ClassCastException`).
    *   **Переиспользование кода:** Один класс/метод может работать с разными типами данных.
    *   **Устранение необходимости явного приведения типов:** Код становится чище и безопаснее.
*   **Стирание типов (Type Erasure):** Информация о типах-параметрах (`<T>`, `<K, V>`) **удаляется** компилятором во время компиляции и заменяется на их верхнюю границу (`Object` по умолчанию, или указанный тип в `extends`). Поэтому в runtime тип `T` недоступен напрямую (нельзя сделать `new T()` или `T.class` без "костылей").
*   **Wildcards (`?`):** Используются для создания гибких API, работающих с обобщенными типами.
    *   **Unbounded (`?`):** `List<?>` - список неизвестного типа. Можно безопасно читать только как `Object`. Нельзя добавлять элементы (кроме `null`).
    *   **Upper Bounded (`? extends Type`):** `List<? extends Number>` - список объектов типа `Number` или его подтипов (`Integer`, `Double`). Безопасно читать элементы как `Number`. Нельзя добавлять элементы (кроме `null`).
    *   **Lower Bounded (`? super Type`):** `List<? super Integer>` - список объектов типа `Integer` или его супертипов (`Number`, `Object`). Безопасно добавлять элементы типа `Integer` (и его подтипов). Читать можно только как `Object`.
*   **Принцип PECS (Producer Extends, Consumer Super):** Мнемоническое правило для использования wildcards в параметрах методов:
    *   **Producer Extends:** Если коллекция является **источником (producer)** данных (вы только **читаете** из нее), используйте `extends` (`List<? extends T>`).
    *   **Consumer Super:** Если коллекция является **потребителем (consumer)** данных (вы только **пишете** в нее), используйте `super` (`List<? super T>`).
    *   Если и читаете, и пишете, не используйте wildcards (используйте точный тип `List<T>`).

### Коллекции

*   **Иерархия:**
    *   `Iterable` (root) -> `Collection`
    *   `Collection` -> `List`, `Set`, `Queue`
    *   `List` (упорядоченный, допускает дубликаты, доступ по индексу): `ArrayList`, `LinkedList`, `Vector` (устар., synchronized), `Stack` (устар., LIFO, наследует Vector).
    *   `Set` (уникальные элементы): `HashSet` (нет порядка, основан на HashMap), `LinkedHashSet` (порядок вставки, основан на LinkedHashMap), `TreeSet` (отсортированный порядок, основан на TreeMap, требует `Comparable` или `Comparator`).
    *   `Queue` (очередь, обычно FIFO): `LinkedList`, `PriorityQueue` (очередь с приоритетом, основана на куче), `ArrayDeque`.
    *   `Deque` (двусторонняя очередь, double-ended queue): `ArrayDeque` (эффективная реализация), `LinkedList`.
    *   `Map` (пары ключ-значение, ключи уникальны, ***не*** наследует `Collection`): `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable` (устар., synchronized), `ConcurrentHashMap`.
*   **Map и Collection - интерфейсы?** Да, оба являются корневыми интерфейсами для соответствующих иерархий.
*   **Принцип работы HashMap:**
    1.  **Структура:** Массив нод (бакетов, buckets). Каждая нода может хранить одну пару ключ-значение или быть началом связного списка/дерева при коллизиях.
    2.  **`put(K key, V value)`:**
        *   Вычисляется `hashCode()` ключа. `null` ключ обрабатывается отдельно (обычно бакет 0).
        *   Хэш дополнительно обрабатывается для лучшего распределения.
        *   Определяется индекс бакета: `index = hash & (capacity - 1)` (где `capacity` - текущая емкость массива, всегда степень двойки).
        *   **Если бакет пуст:** Создается новая нода `Node<K,V>` в этом бакете.
        *   **Если бакет не пуст (коллизия):**
            *   Проверяется, есть ли уже нода с таким же ключом (сначала по ссылке `==`, затем по `hashCode()`, затем по `equals()`).
            *   **Если ключ найден:** Старое значение перезаписывается новым.
            *   **Если ключ не найден:** Новая нода добавляется в конец связного списка в этом бакете.
            *   **Если список становится слишком длинным** (больше `TREEIFY_THRESHOLD`, по умолч. 8): Список преобразуется в сбалансированное красно-черное дерево для ускорения поиска до O(log n) внутри бакета.
    3.  **`get(K key)`:** Аналогично вычисляется индекс бакета, затем идет поиск ключа внутри связного списка или дерева по `hashCode()` и `equals()`.
    4.  **Load Factor (Коэффициент загрузки):** Порог (по умолч. 0.75), при превышении которого (`size > capacity * loadFactor`) происходит `resize`.
    5.  **Resize (Перехеширование):** Емкость массива удваивается (`capacity *= 2`), создается новый массив, и все существующие элементы перераспределяются по новому массиву (пересчитываются их индексы). Дорогая операция.
    6.  **Сложность:** В среднем (при хорошем распределении хэшей) O(1) для `put`, `get`, `remove`. В худшем случае (все элементы в одном бакете) - O(n) для списка или O(log n) для дерева (с Java 8).
*   **Сравнение реализаций:**
    *   **`ArrayList` vs `LinkedList`:**
        *   `ArrayList`: На основе массива. Быстрый доступ по индексу O(1). Медленная вставка/удаление в середине O(n) (сдвиг элементов). Эффективнее по памяти.
        *   `LinkedList`: На основе двусвязного списка. Медленный доступ по индексу O(n) (перебор). Быстрая вставка/удаление в начале/конце O(1) и в середине (если есть итератор). Больше расход памяти (хранение ссылок). Реализует `Queue` и `Deque`.
    *   **`HashMap` vs `TreeMap` vs `LinkedHashMap`:**
        *   `HashMap`: Нет гарантии порядка итерации. Самая быстрая (O(1) в среднем). Позволяет `null` ключ и значения.
        *   `TreeMap`: Хранит элементы отсортированными по ключу (естественный порядок или `Comparator`). Сложность O(log n). Не позволяет `null` ключ (если не задан `Comparator`, который его обработает).
        *   `LinkedHashMap`: Хранит элементы в порядке их вставки (или доступа). Чуть медленнее `HashMap` из-за поддержки связного списка. Позволяет `null` ключ и значения.
    *   **`HashSet` vs `TreeSet`:** Аналогично `HashMap` vs `TreeMap`, но для множеств. `HashSet` - O(1), нет порядка. `TreeSet` - O(log n), отсортированный порядок.

### Исключения

*   **Иерархия:** `Throwable` (корневой класс)
    *   `Error`: Серьезные проблемы, которые приложение обычно не может обработать (например, `OutOfMemoryError`, `StackOverflowError`). Сигнализируют о проблемах в JVM или среде.
    *   `Exception`: Исключительные ситуации, которые приложение может предвидеть и обработать.
        *   **Checked Exceptions (Проверяемые):** Наследники `Exception`, **кроме** `RuntimeException`. **Должны** быть либо обработаны в блоке `try-catch`, либо объявлены в сигнатуре метода с помощью `throws`. Указывают на ожидаемые проблемы во внешней среде (файл не найден - `FileNotFoundException`, ошибка сети - `IOException`, проблема с БД - `SQLException`).
        *   **Unchecked Exceptions (Непроверяемые):** Наследники `RuntimeException`. **Не требуют** явной обработки или объявления `throws` (хотя это возможно). Обычно сигнализируют об ошибках программирования (логических ошибках): `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`, `ClassCastException`.
*   **Обработка Throwable:** **Плохая практика.** Перехват `Throwable` или `Error` может маскировать серьезные проблемы JVM, которые приложение все равно не сможет исправить. Лучше ловить конкретные `Exception` или, в крайнем случае, `Exception`, но не `Throwable`.
*   **try-finally без catch:** Да, можно и полезно. Блок `finally` гарантированно выполнится (кроме `System.exit()` или фатального сбоя JVM), независимо от того, было ли исключение и было ли оно поймано. Используется для освобождения ресурсов (закрытия файлов, соединений и т.д.).
*   **Try-with-resources (Java 7+):** Упрощает работу с ресурсами, которые нужно гарантированно закрыть. Ресурсы (объекты, реализующие `AutoCloseable`) объявляются в скобках после `try`. Метод `close()` для этих ресурсов будет вызван автоматически в конце блока `try` (или при возникновении исключения внутри блока), даже если нет блока `finally`. Это предпочтительный способ работы с ресурсами.
    ```java
    try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"));
         PrintWriter writer = new PrintWriter("output.txt")) {
        // Работа с reader и writer
    } catch (IOException e) {
        // Обработка ошибки
    } // reader.close() и writer.close() вызовутся автоматически
    ```

### Stream API

*   **Что такое:** API для функциональной обработки последовательностей элементов (из коллекций, массивов, генераторов). Позволяет писать декларативный, выразительный код для фильтрации, преобразования, агрегации данных.
*   **Типы операций:**
    *   **Промежуточные (Intermediate):** Ленивые (lazy), не выполняются до вызова терминальной операции. Возвращают новый стрим. Примеры: `filter(Predicate)`, `map(Function)`, `flatMap(Function)`, `sorted()`, `distinct()`, `limit(n)`, `skip(n)`, `peek(Consumer)`. Можно выстраивать цепочки.
    *   **Терминальные (Terminal):** Запускают выполнение всех промежуточных операций в конвейере (pipeline). Завершают стрим, после них его нельзя использовать повторно. Возвращают результат (не стрим) или выполняют побочный эффект. Примеры: `forEach(Consumer)`, `collect(Collector)`, `reduce()`, `count()`, `anyMatch(Predicate)`, `allMatch(Predicate)`, `noneMatch(Predicate)`, `findFirst()`, `findAny()`, `toArray()`.
*   **Операции после терминальной:** Невозможно, стрим уже "потреблен" (consumed). Попытка вызовет `IllegalStateException`.
*   **`map` vs `flatMap`:**
    *   `map(Function<T, R> mapper)`: Преобразует **каждый элемент** `T` стрима в **один** элемент `R`. Отношение "один-к-одному". `Stream<T>` -> `Stream<R>`. Пример: получить длины строк `stream.map(String::length)`.
    *   `flatMap(Function<T, Stream<R>> mapper)`: Преобразует **каждый элемент** `T` стрима в **ноль или более** элементов `R` (возвращая `Stream<R>`), а затем **"сплющивает" (flattens)** все полученные стримы в один результирующий `Stream<R>`. Отношение "один-ко-многим". Используется для работы с вложенными структурами (например, список списков) или когда операция над элементом возвращает коллекцию/стрим. Пример: получить все символы из списка слов `listOfWords.stream().flatMap(word -> word.chars().mapToObj(c -> (char)c))`.
*   **Параллельный Stream (`parallelStream()` или `.parallel()`):**
    *   Позволяет выполнять операции стрима в нескольких потоках, используя общий `ForkJoinPool.commonPool()`.
    *   Может значительно ускорить обработку больших объемов данных на многоядерных процессорах, особенно для CPU-bound задач.
    *   **Особенности:**
        *   Не всегда быстрее: накладные расходы на разделение задачи, синхронизацию и слияние результатов могут перевесить выгоду на маленьких данных или I/O-bound задачах.
        *   Порядок элементов не гарантируется для некоторых операций (например, `forEach`, `findAny`). Если порядок важен, используйте `forEachOrdered`. Терминальные операции, такие как `collect(Collectors.toList())` или `toArray()`, сохраняют порядок исходного стрима.
        *   Требует внимания к потокобезопасности: операции в стриме (лямбды) не должны изменять разделяемое состояние не потокобезопасным образом. Используйте конкурентные коллекции или редукцию.

### Работа с памятью и GC

*   **Области памяти JVM:**
    *   **Heap (Куча):** Основная область для хранения объектов, создаваемых через `new`. Управляется сборщиком мусора. Делится на поколения (Young, Old).
    *   **Stack (Стек):** Для каждого потока создается свой стек. Хранит фреймы методов (локальные переменные примитивных типов, ссылки на объекты в куче). Память освобождается автоматически при выходе из метода.
    *   **Metaspace (с Java 8) / PermGen (до Java 8):** Хранит метаданные классов, пул строк (до Java 7). Metaspace находится в нативной памяти, размер ограничен доступной ОС памятью.
    *   **Native Method Stacks:** Стеки для нативных (не Java) методов.
*   **Сборщик мусора (Garbage Collector, GC):** Автоматический процесс освобождения памяти в куче, занятой объектами, на которые больше нет ссылок из "корней" сборки мусора (GC Roots: локальные переменные на стеках, статические переменные, JNI ссылки).
*   **Принцип работы (упрощенно, Generational Hypothesis):** Большинство объектов умирают молодыми.
    *   **Young Generation (Молодое поколение):** Делится на `Eden` и два `Survivor Spaces` (S0, S1).
        1.  Новые объекты создаются в `Eden`.
        2.  Когда `Eden` заполняется, происходит **Minor GC**.
        3.  Живые объекты из `Eden` и одного из `Survivor` (From-Space) копируются в другой `Survivor` (To-Space). Возраст объектов увеличивается.
        4.  `Eden` и From-Space очищаются. Роли S0 и S1 меняются.
    *   **Old Generation (Tenured, Старое поколение):** Объекты, пережившие определенное количество Minor GC (поріг `MaxTenuringThreshold`), перемещаются (promoted) в Old Gen.
    *   **Major GC (Full GC):** Сборка мусора в Old Gen (часто затрагивает и Young Gen). Обычно более длительная операция.
*   **Алгоритмы GC:**
    *   **Mark-and-Sweep:** 1. Фаза Mark: Помечаются все достижимые объекты. 2. Фаза Sweep: Проход по куче, удаление непомеченных объектов. Минус: фрагментация памяти.
    *   **Mark-and-Compact:** После фазы Sweep добавляется фаза Compact: живые объекты сдвигаются в начало кучи, устраняя фрагментацию. Минус: более длительная пауза.
    *   **Copying Collector:** (Используется в Young Gen) Делит пространство пополам (From/To). Копирует живые объекты из From-Space в To-Space. Быстро, нет фрагментации, но требует x2 памяти.
*   **Stop-the-World (STW) паузы:** Моменты, когда выполнение всех потоков приложения приостанавливается для безопасного выполнения GC. Разные сборщики стремятся минимизировать длительность и частоту этих пауз.
*   **Типы сборщиков мусора (основные):**
    *   **Serial GC (`-XX:+UseSerialGC`):** Однопоточный. Простой, для небольших приложений или клиентских машин. Длинные STW паузы.
    *   **Parallel GC (Throughput GC) (`-XX:+UseParallelGC`):** Многопоточный для Young Gen (Minor GC), может быть многопоточным и для Old Gen (`-XX:+UseParallelOldGC`). Ориентирован на максимальную пропускную способность (throughput). Дефолтный в Java 8. Паузы могут быть значительными.
    *   **CMS (Concurrent Mark Sweep) (`-XX:+UseConcMarkSweepGC`):** Работает большей частью параллельно с приложением, минимизируя STW паузы (особенно для Old Gen). Минусы: фрагментация, может не успевать за приложением (`Concurrent Mode Failure`). Устарел (deprecated в Java 9, удален в 14).
    *   **G1 (Garbage-First) (`-XX:+UseG1GC`):** Делит кучу на множество мелких регионов. Собирает мусор сначала в самых "замусоренных" регионах. Пытается уложиться в заданную целевую паузу (`-XX:MaxGCPauseMillis`). Хороший баланс между паузами и пропускной способностью. Дефолтный с Java 9.
    *   **ZGC (`-XX:+UseZGC`) и Shenandoah (`-XX:+UseShenandoahGC`):** Новейшие сборщики, спроектированные для очень больших куч (терабайты) и минимальных пауз (миллисекунды). Работают почти полностью конкурентно.

### Рефлексия

*   **Что такое:** Механизм Java, позволяющий программе **исследовать (интроспекция)** и **манипулировать** собственными структурами (классами, интерфейсами, полями, методами, конструкторами) **во время выполнения (runtime)**.
*   **Основные классы:** `Class`, `Field`, `Method`, `Constructor`, `Modifier`.
*   **Возможности:**
    *   Получать информацию о классе: имя, модификаторы, суперкласс, интерфейсы, поля, методы, конструкторы (`clazz.getName()`, `clazz.getDeclaredFields()`, `clazz.getDeclaredMethods()`).
    *   Создавать экземпляры классов динамически (`clazz.getDeclaredConstructor().newInstance()`).
    *   Получать и изменять значения полей (`field.setAccessible(true); field.get(obj); field.set(obj, value);`), даже `private`.
    *   Вызывать методы (`method.setAccessible(true); method.invoke(obj, args)`), даже `private`.
*   **Применение:** Фреймворки (Spring DI, Hibernate ORM), инструменты сериализации/десериализации (Jackson), тестовые фреймворки (JUnit), IDE.
*   **Минусы:**
    *   **Производительность:** Операции рефлексии значительно медленнее прямого доступа/вызова.
    *   **Безопасность:** Нарушает инкапсуляцию (доступ к `private` членам).
    *   **Хрупкость:** Рефакторинг (переименование методов/полей) может сломать код, использующий рефлексию через строковые имена.
    *   **Усложнение кода:** Код с рефлексией сложнее читать и отлаживать.

### Иммутабельность

*   **Что такое:** Состояние объекта не может быть изменено после его создания.
*   **Как создать иммутабельный класс:**
    1.  Сделать класс `final` (чтобы нельзя было унаследовать и изменить поведение).
    2.  Сделать все поля `private final`.
    3.  Не предоставлять сеттеры или другие методы, изменяющие состояние.
    4.  Инициализировать все поля в конструкторе.
    5.  Если поля ссылаются на изменяемые объекты (например, `Date`, коллекции), необходимо:
        *   В конструкторе создавать *защитные копии* (defensive copies) входящих изменяемых аргументов.
        *   В геттерах возвращать *защитные копии* внутренних изменяемых полей.
*   **Преимущества:**
    *   **Потокобезопасность:** Иммутабельные объекты по своей природе потокобезопасны, их можно безопасно передавать между потоками без синхронизации.
    *   **Предсказуемость:** Состояние объекта всегда одинаково.
    *   **Кеширование:** Хэш-код можно вычислить один раз и закешировать.
    *   **Безопасность:** Нельзя случайно или намеренно изменить состояние объекта после создания.
*   **Примеры:** `String`, примитивные обертки (`Integer`, `Boolean`...), `java.time` классы.

---

## Concurrency (Многопоточность)

### Основы

*   **Процесс vs Поток (Тред):**
    *   **Процесс:** Экземпляр выполняемой программы. Имеет свое **изолированное** адресное пространство памяти (heap, code segment). Управляется ОС.
    *   **Поток (Thread):** Легковесный процесс внутри основного процесса. Потоки одного процесса **разделяют** общее адресное пространство (heap, static поля), но имеют **свой собственный стек вызовов** (для локальных переменных и последовательности вызовов) и счетчик команд (program counter). Управляются планировщиком потоков JVM/ОС.
*   **Поток vs Тред в Java:** В Java это синонимы, представленные классом `java.lang.Thread`.
*   **Создание потока:**
    1.  **Наследование `Thread`:** Создать класс, наследующий `Thread`, и переопределить его метод `run()`. Создать экземпляр и вызвать `start()`.
    2.  **Реализация `Runnable`:** Создать класс, реализующий интерфейс `Runnable` (у него один метод `run()`). Создать экземпляр `Runnable` и передать его в конструктор `Thread`, затем вызвать `start()`. **Предпочтительный способ**, т.к. позволяет классу наследоваться от другого класса и разделяет задачу (что делать) от исполнителя (кто делает).
    3.  **Лямбда-выражения (Java 8+):** Короткая запись для `Runnable`: `new Thread(() -> { /* код потока */ }).start();`
*   **Состояния потока (`Thread.State`):**
    *   `NEW`: Поток создан (`new Thread()`), но метод `start()` еще не вызван.
    *   `RUNNABLE`: Поток готов к выполнению и ожидает выделения времени CPU планировщиком потоков, либо уже выполняется.
    *   `BLOCKED`: Поток ожидает освобождения **монитора** объекта, чтобы войти в `synchronized` блок/метод, который занят другим потоком.
    *   `WAITING`: Поток находится в состоянии ожидания **бесконечно**, пока другой поток его явно не "разбудит". Причины: вызов `object.wait()` (без таймаута), `thread.join()` (без таймаута), `LockSupport.park()`.
    *   `TIMED_WAITING`: Поток находится в состоянии ожидания **определенное время**. Причины: `Thread.sleep(millis)`, `object.wait(millis)`, `thread.join(millis)`, `lock.tryLock(time, unit)`, `LockSupport.parkNanos()`, `LockSupport.parkUntil()`.
    *   `TERMINATED`: Поток завершил выполнение своего метода `run()` (нормально или из-за исключения).
*   **Демон-потоки vs Пользовательские:**
    *   **Пользовательские (User Threads):** Стандартные потоки. JVM **не завершит** работу, пока хотя бы один пользовательский поток активен.
    *   **Демоны (Daemon Threads):** Фоновые потоки, выполняющие сервисные задачи (например, GC, обработчики `finalize`). JVM **не ждет** завершения демонов для окончания работы. Если все пользовательские потоки завершились, JVM просто останавливает все демоны и завершается. Устанавливается вызовом `thread.setDaemon(true)` **до** вызова `thread.start()`.

### Синхронизация

*   **Проблема:** При доступе нескольких потоков к общим изменяемым данным могут возникать **состояния гонки (race conditions)**, приводящие к непредсказуемым и неверным результатам. Необходимы механизмы для координации доступа.
*   **`synchronized` (ключевое слово):** Встроенный механизм блокировки в Java, основанный на **мониторах**.
    *   **Монитор:** Каждый объект Java имеет связанный с ним неявный монитор.
    *   **Использование:**
        *   **Синхронизированный метод экземпляра:** `public synchronized void method() { ... }`. Блокируется монитор объекта (`this`). Только один поток может выполнять любой `synchronized` метод *этого* объекта в данный момент времени.
        *   **Синхронизированный статический метод:** `public static synchronized void method() { ... }`. Блокируется монитор объекта `Class` (`MyClass.class`). Только один поток может выполнять любой `static synchronized` метод *этого класса*.
        *   **Синхронизированный блок:** `synchronized (object) { ... }`. Блокируется монитор указанного объекта `object`. Позволяет блокировать не весь метод, а только критическую секцию, и использовать любой объект в качестве замка.
*   **`volatile` (ключевое слово):** Модификатор переменной. **Гарантирует:**
    1.  **Видимость (Visibility):** Запись в `volatile` переменную происходит *до* любого последующего чтения этой переменной другим потоком (устанавливает отношение happens-before). Гарантирует, что потоки будут видеть актуальное значение переменной, а не кешированное.
    2.  **Упорядоченность (Ordering):** Предотвращает некоторые виды переупорядочивания инструкций компилятором и процессором относительно `volatile` чтений/записей.
    *   **НЕ гарантирует атомарность** для составных операций (типа `count++`, которая состоит из чтения, инкремента и записи). Для атомарности используйте `Atomic*` классы или блокировки.
*   **`Lock` (интерфейс `java.util.concurrent.locks.Lock`):** Явный механизм блокировки, более гибкий, чем `synchronized`.
    *   **`ReentrantLock`:** Распространенная реализация `Lock`. "Повторно входимая" - поток, уже владеющий блокировкой, может захватить ее снова, не блокируя сам себя.
    *   **Использование:**
        ```java
        Lock lock = new ReentrantLock();
        // ...
        lock.lock(); // Захват блокировки (блокирует поток, если она занята)
        try {
            // Критическая секция
        } finally {
            lock.unlock(); // !!! Обязательно освободить блокировку в finally !!!
        }
        ```
*   **Встроенные vs Явные блокировки (`synchronized` vs `Lock`):**
    *   **`synchronized` (Встроенная/Неявная):**
        *   Проще синтаксис.
        *   Блокировка **всегда** освобождается корректно при выходе из блока (не нужно `finally`).
        *   Негибкая: нельзя прервать ожидание, нельзя попробовать захватить без блокирования (`tryLock`), нет условий (`Condition`). Встроена в язык.
    *   **`Lock` (Явная, например `ReentrantLock`):**
        *   **Обязательно** требует ручного `unlock()` в `finally`. Легко забыть и получить deadlock.
        *   Более гибкая:
            *   `tryLock()`: Попытка захвата без блокировки или с таймаутом.
            *   `lockInterruptibly()`: Возможность прервать поток, ожидающий блокировку.
            *   Возможность создания `Condition` (условий) для сложной координации (`await`/`signal`/`signalAll` - аналог `wait`/`notify`/`notifyAll`).
            *   Поддержка "честных" (fair) блокировок (гарантируют порядок захвата, но снижают производительность).
            *   Реализована как обычная библиотека Java.
*   **Java Memory Model (JMM):** Спецификация, которая определяет, как потоки Java взаимодействуют через память. Гарантирует, когда изменения, сделанные одним потоком, становятся видимы другим. Ключевые концепции: happens-before (гарантирует порядок и видимость операций), `volatile`, `final` поля, `synchronized`, `Lock`.

### Потокобезопасность (Thread Safety)

*   **Определение:** Класс или метод является потокобезопасным, если он ведет себя корректно при вызове из нескольких потоков одновременно, без дополнительной синхронизации со стороны вызывающего кода. Состояние объекта остается согласованным.
*   **Способы достижения:**
    *   **Иммутабельность:** Создание неизменяемых объектов (см. раздел Java Core). Самый надежный способ.
    *   **Синхронизация:** Использование `synchronized` или `java.util.concurrent.locks.Lock` для защиты доступа к изменяемому состоянию (критическим секциям).
    *   **Конкурентные коллекции:** Использование потокобезопасных коллекций из `java.util.concurrent` (например, `ConcurrentHashMap`, `CopyOnWriteArrayList`, `BlockingQueue`).
    *   **Атомарные переменные:** Использование классов из `java.util.concurrent.atomic` (`AtomicInteger`, `AtomicReference` и т.д.) для простых атомарных операций (инкремент, CAS - Compare-and-Swap).
    *   **ThreadLocal:** Создание переменных, локальных для каждого потока. У каждого потока своя копия переменной, что устраняет необходимость в синхронизации.

### Deadlock (Взаимная блокировка)

*   **Определение:** Ситуация, когда два или более потока находятся в состоянии бесконечного ожидания друг друга, так как каждый поток удерживает ресурс, необходимый другому потоку, и ожидает ресурс, удерживаемый другим.
*   **Условия возникновения (Условия Коффмана - все 4 должны выполняться):**
    1.  **Взаимное исключение (Mutual Exclusion):** Ресурс может быть занят только одним потоком в данный момент.
    2.  **Удержание и ожидание (Hold and Wait):** Поток удерживает хотя бы один ресурс и запрашивает дополнительные ресурсы, занятые другими потоками.
    3.  **Неперераспределяемость ресурсов (No Preemption):** Ресурс не может быть принудительно отобран у потока; он должен быть освобожден только потоком, который его удерживает.
    4.  **Циклическое ожидание (Circular Wait):** Существует цепочка из двух или более потоков, где каждый поток ожидает ресурс, удерживаемый следующим потоком в цепочке.
*   **Способы предотвращения/борьбы:**
    *   **Нарушение условий:** Стараться избегать выполнения одного из 4 условий (самый частый способ - нарушение циклического ожидания).
    *   **Порядок захвата блокировок:** Все потоки должны захватывать блокировки (ресурсы) в строго определенном, одинаковом порядке.
    *   **Таймауты:** Использовать `lock.tryLock(timeout)` вместо `lock.lock()`. Если не удалось захватить блокировку за таймаут, можно освободить уже захваченные и попробовать позже.
    *   **Обнаружение Deadlock:** JVM может обнаруживать некоторые deadlock (мониторные), можно анализировать Thread Dump.

### Executor Framework

*   Абстракция над управлением потоками, часть `java.util.concurrent`. Позволяет отделить логику задачи от логики управления потоками (создание, запуск, пулы).
*   **Основные интерфейсы/классы:**
    *   **`Executor`:** Базовый интерфейс с одним методом `execute(Runnable command)`. Просто запускает задачу.
    *   **`ExecutorService`:** Расширяет `Executor`. Добавляет методы для управления жизненным циклом пула (`shutdown()`, `shutdownNow()`, `isTerminated()`) и для работы с задачами, возвращающими результат (`submit(Callable<T>)`, `submit(Runnable, T)`).
    *   **`Callable<V>`:** Интерфейс задачи, похожий на `Runnable`, но метод `call()` может возвращать результат (`V`) и бросать checked исключения.
    *   **`Future<V>`:** Представляет результат асинхронной операции. Позволяет проверить, завершена ли задача (`isDone()`), отменить ее (`cancel()`), получить результат (блокирующий метод `get()`, или `get(timeout)`).
    *   **`Executors`:** Фабричный класс для создания стандартных пулов потоков:
        *   `newFixedThreadPool(int nThreads)`: Пул с фиксированным числом потоков. Если все потоки заняты, задачи ставятся в очередь.
        *   `newCachedThreadPool()`: Пул, который создает новые потоки по мере необходимости и переиспользует простаивающие. Может создавать очень много потоков.
        *   `newSingleThreadExecutor()`: Пул с одним потоком. Гарантирует последовательное выполнение задач.
        *   `newScheduledThreadPool(int corePoolSize)`: Пул для отложенного или периодического выполнения задач.
    *   **`ThreadPoolExecutor`:** Конкретная реализация `ExecutorService` с гибкой настройкой (размер ядра, максимальный размер, время жизни потоков, очередь задач, политика отклонения).
*   **`ScheduledExecutorService`:** Расширяет `ExecutorService`. Позволяет планировать выполнение задач:
    *   `schedule(Callable<V> callable, long delay, TimeUnit unit)`: Выполнить один раз с задержкой.
    *   `scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)`: Выполнять периодически с фиксированным интервалом **между началами** выполнений.
    *   `scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)`: Выполнять периодически с фиксированной задержкой **между окончанием** одного выполнения и началом следующего.

### java.util.concurrent

Пакет, предоставляющий высокоуровневые утилиты для конкурентного программирования. Включает:
*   **Атомарные переменные (`java.util.concurrent.atomic`):** `AtomicBoolean`, `AtomicInteger`, `AtomicLong`, `AtomicReference`. Предоставляют атомарные операции (например, `compareAndSet`, `getAndIncrement`) без использования блокировок (lock-free), что часто эффективнее.
*   **Блокировки (`java.util.concurrent.locks`):** `Lock`, `ReentrantLock`, `ReadWriteLock` (интерфейс), `ReentrantReadWriteLock` (реализация, позволяет множеству читателей или одному писателю одновременно).
*   **Синхронизаторы:**
    *   `Semaphore`: Ограничивает количество потоков, которые могут одновременно получить доступ к определенному ресурсу или секции кода (`acquire()`, `release()`).
    *   `CountDownLatch`: Позволяет одному или нескольким потокам ожидать, пока не завершится определенное количество операций в других потоках (`countDown()`, `await()`). Одноразовый.
    *   `CyclicBarrier`: Позволяет набору потоков ожидать друг друга на "барьере", пока все не достигнут его, после чего они могут продолжить выполнение (опционально выполняется действие на барьере). Переиспользуемый.
    *   `Exchanger`: Позволяет двум потокам обменяться данными в точке синхронизации (`exchange()`).
    *   `Phaser`: Более гибкий и мощный синхронизатор, чем `CountDownLatch` и `CyclicBarrier`.
*   **Конкурентные коллекции:** Потокобезопасные реализации стандартных интерфейсов коллекций.
    *   `ConcurrentHashMap`: Высокопроизводительная потокобезопасная реализация `Map`. Использует блокировку по сегментам/бакетам, а не всего объекта.
    *   `CopyOnWriteArrayList`, `CopyOnWriteArraySet`: Потокобезопасные за счет копирования всей внутренней структуры при каждой модификации (записи). Чтение очень быстрое и не требует блокировок. Подходят для сценариев, где чтений гораздо больше, чем записей.
    *   `BlockingQueue<E>` (интерфейс): Очередь, которая блокирует поток при попытке добавить элемент в полную очередь (`put`) или извлечь из пустой (`take`). Реализации: `ArrayBlockingQueue` (на массиве, ограниченный размер), `LinkedBlockingQueue` (на связном списке, опционально ограниченный), `PriorityBlockingQueue` (с приоритетом), `SynchronousQueue` (без внутреннего буфера, передача напрямую).

### ForkJoinPool

*   Специализированный `ExecutorService`, предназначенный для задач, которые можно рекурсивно разбить на более мелкие подзадачи (принцип "разделяй и властвуй", divide and conquer).
*   Использует **work-stealing** алгоритм: свободные потоки "крадут" задачи из очередей других потоков, что обеспечивает эффективную загрузку процессоров.
*   Основа для `parallelStream()` и `CompletableFuture`.
*   Основные классы задач: `RecursiveTask<V>` (возвращает результат), `RecursiveAction` (не возвращает результат).
*   Методы: `fork()` (асинхронно запускает подзадачу), `join()` (ожидает и получает результат подзадачи).

---

## Базы данных и Persistence

### Общие концепции БД

*   **ACID:** Акроним, описывающий свойства, гарантирующие надежность транзакций в базах данных:
    *   **Atomicity (Атомарность):** Транзакция выполняется как единое целое: либо все ее операции успешно завершаются, либо ни одна из них не оказывает влияния на данные (все изменения откатываются). "Всё или ничего".
    *   **Consistency (Согласованность):** Транзакция переводит базу данных из одного согласованного (валидного) состояния в другое. Все ограничения целостности (primary keys, foreign keys, checks) должны быть удовлетворены до и после транзакции.
    *   **Isolation (Изоляция):** Параллельно выполняющиеся транзакции не должны мешать друг другу. Результат параллельного выполнения должен быть эквивалентен некоторому последовательному выполнению этих транзакций. Определяется уровнями изоляции.
    *   **Durability (Долговечность):** Если транзакция успешно завершена (закоммичена), ее результаты должны быть сохранены постоянно и не должны быть потеряны даже в случае сбоев системы (отключение питания, крах ОС). Обычно обеспечивается записью в журналы транзакций (WAL).
*   **Уровни изоляции транзакций:** Определяют, какие аномалии конкурентного доступа допустимы между параллельными транзакциями. От низшего к высшему:
    1.  **Read Uncommitted (Чтение незафиксированных данных):** Транзакция может читать изменения, сделанные другими транзакциями, которые еще не были зафиксированы (commit).
        *   **Аномалия:** **Грязное чтение (Dirty Read)** - чтение данных, которые потом будут отменены (rollback).
    2.  **Read Committed (Чтение зафиксированных данных):** Транзакция видит только те изменения, которые были зафиксированы другими транзакциями на момент начала *операции чтения*. Предотвращает Dirty Read. **Уровень по умолчанию для большинства БД (PostgreSQL, Oracle, SQL Server).**
        *   **Аномалия:** **Неповторяемое чтение (Non-Repeatable Read)** - повторное чтение одной и той же строки в рамках *одной* транзакции может вернуть разные результаты, если другая транзакция успела изменить и закоммитить эту строку между чтениями.
        *   **Аномалия:** **Фантомное чтение (Phantom Read)** - повторное выполнение запроса с одним и тем же условием `WHERE` в рамках *одной* транзакции может вернуть разное *количество* строк, если другая транзакция успела добавить/удалить строки, удовлетворяющие условию, и закоммитить их.
    3.  **Repeatable Read (Повторяемое чтение):** Гарантирует, что повторное чтение одной и той же строки в рамках одной транзакции всегда вернет те же значения. Предотвращает Dirty Read и Non-Repeatable Read. **Уровень по умолчанию для MySQL (InnoDB).**
        *   **Аномалия:** **Фантомное чтение (Phantom Read)** все еще возможно (хотя некоторые реализации БД могут его предотвращать).
    4.  **Serializable (Сериализуемый):** Самый строгий уровень. Гарантирует, что результат параллельного выполнения транзакций эквивалентен их некоторому последовательному выполнению. Предотвращает все аномалии (Dirty Read, Non-Repeatable Read, Phantom Read). Обычно реализуется через строгие блокировки, что может сильно снизить производительность и параллелизм.
*   **Локи (Locks):** Механизмы, используемые СУБД для реализации изоляции и управления конкурентным доступом к данным (строкам, страницам, таблицам).
    *   **Pessimistic Locking (Пессимистическая блокировка):** Блокирует ресурс (например, строку через `SELECT ... FOR UPDATE`) **сразу** при чтении или перед изменением, предполагая, что конфликт вероятен. Другие транзакции не смогут изменить (а иногда и прочитать) заблокированный ресурс до освобождения блокировки. Подходит при высокой вероятности конфликтов.
    *   **Optimistic Locking (Оптимистическая блокировка):** **Не блокирует** ресурс при чтении. Вместо этого, при попытке **обновить** данные, проверяется, не были ли они изменены другой транзакцией с момента их чтения. Обычно реализуется через **поле версии** (`@Version` в JPA) или timestamp. Если обнаружен конфликт (версия изменилась), операция обновления прерывается (обычно исключением), и приложению нужно решить, как действовать (повторить транзакцию, сообщить пользователю). Подходит при низкой вероятности конфликтов, обеспечивает больший параллелизм.
*   **Индексы:** Специальные структуры данных (чаще всего B-деревья), которые СУБД использует для **ускорения поиска** данных в таблицах. Индекс хранит значения одного или нескольких столбцов и указатели на соответствующие строки.
    *   Ускоряют операции `SELECT` с условиями `WHERE` по индексированным столбцам, а также `JOIN` и `ORDER BY`.
    *   Замедляютоперации `INSERT`, `UPDATE`, `DELETE`, так как индекс тоже нужно обновлять.
    *   Требуют дополнительного места на диске.

### JDBC vs ORM/JPA

*   **JDBC (Java Database Connectivity):** Низкоуровневый Java API для взаимодействия с реляционными базами данных.
    *   Требует написания SQL-запросов вручную в виде строк.
    *   Требует ручного маппинга данных из `ResultSet` в Java-объекты и обратно.
    *   Требует явного управления ресурсами (Connection, Statement, ResultSet - закрытие в `finally` или try-with-resources).
    *   Требует ручного управления транзакциями (`connection.setAutoCommit(false)`, `commit()`, `rollback()`).
    *   Дает полный контроль над SQL, но код часто шаблонный и громоздкий.
*   **ORM (Object-Relational Mapping):** Технология (и инструменты), которая автоматически отображает (маппит) объекты Java на таблицы в реляционной базе данных и наоборот. Позволяет разработчику работать с данными БД в терминах объектов и классов, а не SQL-запросов и таблиц.
*   **JPA (Java Persistence API / Jakarta Persistence):** Стандартная **спецификация** Java EE / Jakarta EE для ORM. Определяет набор интерфейсов, аннотаций (`@Entity`, `@Table`, `@Id`, `@Column`, `@OneToMany` и т.д.) и API (`EntityManager`) для управления персистентностью объектов.
*   **Hibernate:** Одна из самых популярных и полнофункциональных **реализаций** спецификации JPA. Предоставляет `EntityManager` и дополнительные возможности. Другие реализации: EclipseLink, OpenJPA.
*   **Преимущества ORM/JPA над JDBC:**
    *   **Уменьшение шаблонного кода:** ORM берет на себя рутину маппинга, управления ресурсами, генерации базовых CRUD SQL-запросов.
    *   **Объектно-ориентированный подход:** Работа с объектами, их полями и связями. Код становится более понятным и соответствующим бизнес-логике.
    *   **Абстракция от БД:** Спецификация JPA и ORM-инструменты скрывают многие детали конкретной СУБД. Использование JPQL/HQL (объектно-ориентированных языков запросов) вместо чистого SQL повышает переносимость кода между разными СУБД.
    *   **Управление связями:** Легко моделировать и работать со связями между сущностями (one-to-one, one-to-many, many-to-many).
    *   **Кеширование:** Встроенные механизмы кеширования (L1 Cache - уровень сессии/EntityManager, L2 Cache - уровень фабрики сессий/EntityManagerFactory) могут значительно повысить производительность за счет уменьшения обращений к БД.
    *   **Управление транзакциями:** Часто интегрируется с декларативным управлением транзакциями (например, в Spring).
    *   **Генерация схемы:** Возможность автоматической генерации или обновления схемы БД на основе метаданных сущностей (для разработки/тестирования).

### JPA/Hibernate

*   **Entity (Сущность):** Java-класс, помеченный аннотацией `@Entity`, экземпляры которого могут быть сохранены в базе данных. Обычно соответствует таблице в БД. Должен иметь первичный ключ (`@Id`).
*   **EntityManager:** Основной интерфейс JPA для взаимодействия с контекстом персистентности (persistence context). Позволяет сохранять (`persist`), находить (`find`), обновлять (`merge`), удалять (`remove`) сущности и выполнять запросы (`createQuery`).
*   **Persistence Context (Контекст персистентности):** Набор управляемых экземпляров сущностей (`managed entities`). EntityManager отслеживает изменения в этих сущностях и синхронизирует их с БД во время flush/commit транзакции. Действует как кэш первого уровня (L1 Cache).
*   **Состояния сущности:**
    *   **Transient (Новый):** Объект только что создан (`new User()`), не связан с Persistence Context и не имеет представления в БД.
    *   **Managed (Управляемый):** Объект связан с Persistence Context (получен через `find` или `createQuery`, либо после вызова `persist`). Изменения в нем отслеживаются и будут синхронизированы с БД.
    *   **Detached (Отсоединенный):** Объект ранее был Managed, но Persistence Context был закрыт (или вызван `detach()`). Изменения больше не отслеживаются. Может быть снова присоединен с помощью `merge()`.
    *   **Removed (Удаленный):** Объект помечен для удаления из БД (после вызова `remove()`). Будет удален из БД при коммите транзакции.
*   **Стратегии Fetching (Загрузки связей `@OneToMany`, `@ManyToOne` и т.д.):** Определяют, когда загружаются данные связанных сущностей.
    *   **`FetchType.LAZY` (Ленивая):** Связанные сущности/коллекции **не** загружаются из БД сразу вместе с основной сущностью. Они загружаются только при **первом обращении** к соответствующему полю/геттеру. Требует наличия активной сессии/транзакции Hibernate в момент обращения, иначе будет `LazyInitializationException`. ***По умолчанию для коллекций (`@OneToMany`, `@ManyToMany`).***
    *   **`FetchType.EAGER` (Жадная):** Связанные сущности/коллекции загружаются **сразу** вместе с основной сущностью одним или несколькими запросами (в зависимости от типа связи и реализации). ***По умолчанию для одиночных связей (`@ManyToOne`, `@OneToOne`).*** Может приводить к загрузке лишних данных и проблеме N+1.
*   **Проблема N+1:** Возникает, когда для загрузки N связанных сущностей (например, комментариев к N постам) выполняется 1 начальный запрос (загрузка N постов) и затем N дополнительных запросов (по одному запросу комментариев для каждого поста). Сильно снижает производительность.
*   **Решения проблемы N+1:**
    *   **JOIN FETCH (в JPQL/HQL):** Указать JPA/Hibernate загрузить связанные сущности **одним** запросом с использованием `JOIN`.
        ```jpql
        SELECT p FROM Post p JOIN FETCH p.comments WHERE p.author = :author
        ```
    *   **EntityGraph:** Определить граф сущностей (через аннотации `@NamedEntityGraph` или программно), указывая, какие атрибуты/связи нужно загрузить EAGER для конкретного запроса. Передается как hint к запросу (`javax.persistence.fetchgraph` - загружать только указанное, `javax.persistence.loadgraph` - загружать указанное + то, что помечено EAGER по умолчанию).
    *   **@BatchSize (Hibernate):** Аннотация над классом сущности или коллекцией. Указывает Hibernate загружать LAZY-коллекции/сущности пачками (batches). Например, при `@BatchSize(size = 20)` вместо N запросов будет выполнено N/20 + 1 запросов.
    *   **Сменить FetchType на LAZY** для `@ManyToOne`/`@OneToOne` и загружать их явно через `JOIN FETCH` или `EntityGraph` только там, где они действительно нужны.
*   **Получение данных LAZY сущностей вне транзакции:** Если попытаться получить доступ к LAZY-полю после закрытия сессии/транзакции, возникнет `LazyInitializationException`.
    *   **Решения:**
        1.  Использовать `JOIN FETCH` или `EntityGraph` в запросе репозитория, чтобы данные загрузились сразу.
        2.  Расширить границы транзакции (`@Transactional` на методе сервиса, который работает с сущностью и ее LAZY полями).
        3.  Явно инициализировать прокси перед закрытием сессии: `Hibernate.initialize(entity.getLazyCollection());` (требует зависимости Hibernate).
        4.  Использовать DTO Projection (выбирать только нужные поля в запросе, не загружая всю сущность).
*   **Cascade Types (Каскадные операции):** Определяют, как операции (`persist`, `merge`, `remove`, `refresh`, `detach`), примененные к родительской сущности, влияют на связанные дочерние сущности. Задаются в параметре `cascade` аннотаций связей (`@OneToMany(cascade = CascadeType.ALL)`).
    *   `CascadeType.PERSIST`: При сохранении родителя (`persist`) сохраняются и новые (transient) дочерние.
    *   `CascadeType.MERGE`: При обновлении/слиянии отсоединенного родителя (`merge`) обновляются/сливаются и дочерние.
    *   `CascadeType.REMOVE`: При удалении родителя (`remove`) удаляются и связанные дочерние. **Осторожно использовать!**
    *   `CascadeType.REFRESH`: При обновлении состояния родителя из БД (`refresh`) обновляется и состояние дочерних.
    *   `CascadeType.DETACH`: При отсоединении родителя от контекста персистентности (`detach`) отсоединяются и дочерние.
    *   `CascadeType.ALL`: Включает все вышеперечисленные типы каскадирования. Удобно, но может приводить к нежелательным последствиям (например, случайное удаление).
*   **Orphan Removal (`orphanRemoval = true`):** Параметр аннотаций `@OneToMany`, `@OneToOne`. Если `true`, то при удалении дочерней сущности из **коллекции** родителя (например, `parent.getChildren().remove(child)`) или при установке ссылки на `null` (`parent.setChild(null)`), эта дочерняя сущность будет автоматически **удалена из базы данных** при синхронизации. Отличается от `CascadeType.REMOVE`, который срабатывает только при удалении самого родителя.
*   **Генераторы ID (`@GeneratedValue`):** Стратегии генерации значений для первичных ключей (`@Id`).
    *   `GenerationType.AUTO` (по умолчанию): JPA провайдер (Hibernate) сам выбирает подходящую стратегию для данной СУБД (обычно `SEQUENCE` или `IDENTITY`).
    *   `GenerationType.IDENTITY`: Использует механизм автоинкрементного столбца базы данных (например, `AUTO_INCREMENT` в MySQL, `IDENTITY` в SQL Server). ID генерируется **при вставке** (`INSERT`) строки в БД. Не очень подходит для батчинга вставок.
    *   `GenerationType.SEQUENCE`: Использует последовательность (sequence) базы данных (например, в Oracle, PostgreSQL). JPA провайдер получает ID из sequence **перед вставкой** (`INSERT`). Обычно более производительная и лучше подходит для батчинга. Требует настройки `@SequenceGenerator`.
    *   `GenerationType.TABLE`: Использует отдельную таблицу в базе данных для генерации ID (симулирует sequence). Самый медленный и неэффективный, используется редко (для БД без поддержки sequence/identity). Требует настройки `@TableGenerator`.
*   **Составной ключ (Composite Key):** Первичный ключ, состоящий из нескольких полей/столбцов. В JPA реализуется двумя основными способами:
    1.  **`@EmbeddedId`:** Создается отдельный класс для ключа, помечается аннотацией `@Embeddable`. Этот класс должен реализовывать `Serializable` и переопределять `equals()` и `hashCode()`. В классе сущности поле этого типа помечается `@EmbeddedId`.
    2.  **`@IdClass`:** Указывается внешний класс (`@IdClass(CompositeKey.class)`) в аннотации над сущностью. Этот класс содержит те же поля, что и составной ключ, реализует `Serializable`, `equals()` и `hashCode()`. Поля, входящие в составной ключ, помечаются аннотацией `@Id` в самой сущности.
*   **Пагинация:** Получение данных из БД порциями (страницами) для отображения или обработки.
    *   **Offset-based Pagination (LIMIT/OFFSET):** Запрос получает `LIMIT <pageSize>` строк, пропуская `OFFSET <pageNumber * pageSize>` строк.
        *   **JPQL/Criteria API:** `query.setFirstResult(pageNumber * pageSize).setMaxResults(pageSize)`.
        *   **Spring Data JPA:** Использует интерфейс `Pageable` (передающийся в метод репозитория) и возвращает объект `Page<T>`. Обычно реализует offset-based пагинацию.
        *   **Плюсы:** Просто реализуется, позволяет легко перейти на любую страницу.
        *   **Минусы:** Может быть неэффективным на больших значениях `OFFSET`, так как БД все равно должна прочитать и пропустить все строки до начала нужной страницы. Возможны пропуски/дублирования данных при изменении набора данных между запросами страниц.
    *   **Keyset-based Pagination (Cursor-based):** Использует значения ключа (или уникального упорядоченного столбца) последнего элемента на предыдущей странице для получения следующей страницы. Например: `SELECT ... WHERE (creation_date > :last_date OR (creation_date = :last_date AND id > :last_id)) ORDER BY creation_date, id LIMIT :pageSize`.
        *   **Плюсы:** Более производительна на больших таблицах (использует индексы эффективно). Стабильна при добавлении/удалении данных (не пропускает элементы).
        *   **Минусы:** Позволяет двигаться только вперед/назад относительно текущей позиции. Сложно перейти на произвольную страницу N. Требует наличия уникального, упорядоченного столбца (или комбинации).
    *   **Другие виды:** Пагинация с использованием оконных функций (`ROW_NUMBER()`).

### Миграции (Liquibase)

*   **Что такое:** Инструмент для управления изменениями схемы базы данных версионным способом. Позволяет описывать изменения схемы (создание/изменение таблиц, добавление колонок, вставка данных и т.д.) в виде файлов (changelogs), обычно XML, YAML, JSON или SQL. Liquibase отслеживает, какие изменения уже были применены к конкретной БД, и применяет только новые.
*   **Зачем нужно:** Обеспечивает контролируемое, повторяемое и автоматизированное обновление схемы БД в различных окружениях (разработка, тестирование, продакшен). Упрощает командную работу над проектом.
*   **Подключение (Spring Boot):**
    1.  Добавить зависимость `org.liquibase:liquibase-core` в `pom.xml` или `build.gradle`.
    2.  Создать мастер-файл changelog (например, `src/main/resources/db/changelog/db.changelog-master.yaml`).
    3.  Spring Boot автоматически подхватит Liquibase и запустит миграции при старте приложения (если не отключено). Путь к мастер-файлу можно указать в `application.properties` (`spring.liquibase.change-log=...`), но часто используется путь по умолчанию.
*   **Основные компоненты:**
    *   **Changelog File:** Файл (XML, YAML и т.д.), содержащий последовательность изменений (changesets). Мастер-файл может включать (`include`) другие файлы.
    *   **Changeset:** Атомарная единица изменения схемы. Имеет уникальный `id` и `author`, что позволяет Liquibase отслеживать его выполнение. Содержит одно или несколько **Change Types**.
    *   **Change Type:** Конкретное действие над БД (`createTable`, `addColumn`, `insert`, `sql`, `dropTable` и т.д.).
    *   **Preconditions:** Условия, которые должны быть выполнены перед применением changeset (`<preConditions onFail="MARK_RAN">`). Позволяют делать миграции идемпотентными или зависимыми от состояния БД.
        *   `onFail`: Что делать, если условие не выполнено (`HALT` - остановить, `WARN` - продолжить с предупреждением, `MARK_RAN` - пометить как выполненный без выполнения, `CONTINUE` - синоним WARN, `SKIP` - пропустить изменения).
        *   Типы проверок: `tableExists`, `columnExists`, `indexExists`, `foreignKeyConstraintExists`, `sqlCheck`, `dbms`, `changeSetExecuted` и др.
*   **Таблицы Liquibase:** Liquibase создает в БД служебные таблицы (`DATABASECHANGELOG` и `DATABASECHANGELOGLOCK`) для отслеживания примененных изменений и блокировки БД на время миграции.

### Безопасность (SQL Injection)

*   **Что такое:** Тип атаки на веб-приложения, при котором злоумышленник внедряет (инъектирует) вредоносный SQL-код в запросы к базе данных через пользовательский ввод (например, поля формы, параметры URL).
*   **Последствия:** Несанкционированный доступ к данным (чтение), изменение или удаление данных, получение контроля над сервером БД, отказ в обслуживании.
*   **Причина:** Неправильная обработка пользовательского ввода при формировании SQL-запросов, чаще всего - **конкатенация строк** для создания SQL с использованием данных, полученных от пользователя.
    ```java
    // УЯЗВИМЫЙ КОД:
    String userName = request.getParameter("username");
    String sql = "SELECT * FROM users WHERE name = '" + userName + "'"; // Злоумышленник может ввести: ' OR '1'='1
    Statement stmt = connection.createStatement();
    ResultSet rs = stmt.executeQuery(sql); // Выполнится: SELECT * FROM users WHERE name = '' OR '1'='1'
    ```
*   **Защита:**
    1.  **Prepared Statements (Параметризованные запросы):** **Основной и самый надежный метод.** SQL-запрос формируется с плейсхолдерами (`?`) вместо пользовательских данных. Данные передаются отдельно через методы `setXxx()`. Драйвер БД сам корректно обрабатывает (экранирует) данные, предотвращая их интерпретацию как часть SQL-кода.
        ```java
        // БЕЗОПАСНЫЙ КОД:
        String userName = request.getParameter("username");
        String sql = "SELECT * FROM users WHERE name = ?";
        PreparedStatement pstmt = connection.prepareStatement(sql);
        pstmt.setString(1, userName); // Данные передаются как параметр
        ResultSet rs = pstmt.executeQuery();
        ```
    2.  **Использование ORM (JPA/Hibernate):** ORM-фреймворки по умолчанию используют Prepared Statements при работе с сущностями и генерации запросов. JPQL/HQL запросы с именованными (`:param`) или позиционными (`?1`) параметрами также безопасны, если параметры устанавливаются через API запроса (`query.setParameter("param", value)`). **Однако, если вы строите JPQL/HQL запросы конкатенацией строк с пользовательским вводом, уязвимость остается!**
    3.  **Валидация и Санитизация ввода:** Проверяйте и очищайте все данные, поступающие от пользователя, на соответствие ожидаемому формату и допустимым значениям. Отвергайте некорректный ввод. Используйте "белые списки" допустимых символов/значений вместо "черных списков" запрещенных.
    4.  **Принцип наименьших привилегий:** Пользователь базы данных, от имени которого работает приложение, должен иметь только минимально необходимые права доступа к таблицам и операциям. Не используйте `root` или `sa`.
    5.  **Хранимые процедуры (Stored Procedures):** Могут помочь, если они написаны безопасно и не используют динамический SQL внутри с непроверенными параметрами.
    6.  **Экранирование (Escaping):** Ручное экранирование спецсимволов в пользовательском вводе - **менее надежный** метод, легко допустить ошибку. Лучше использовать Prepared Statements.

---

## Spring Framework

### Основы Spring и Spring Boot

*   **Spring Framework:** Комплексный и модульный фреймворк для разработки Java-приложений (в основном для бэкенда). Ключевые концепции:
    *   **Inversion of Control (IoC) / Dependency Injection (DI):** Управление жизненным циклом объектов (бинов) и их зависимостей передается контейнеру Spring.
    *   **Aspect-Oriented Programming (AOP):** Позволяет выделять сквозную функциональность (логирование, транзакции, безопасность).
    *   **Абстракции:** Предоставляет удобные абстракции над стандартными Java EE API (JDBC, JPA, JMS, Servlets).
*   **Spring Boot:** Надстройка над Spring Framework, созданная для **упрощения и ускорения** разработки Spring-приложений. Основные цели:
    *   **Минимум конфигурации:** Соглашения важнее конфигурации (Convention over Configuration).
    *   **Автоконфигурация:** Автоматически настраивает бины и инфраструктуру Spring на основе зависимостей в classpath и настроек в `application.properties/yml`.
    *   **Starter-зависимости:** Упрощают управление зависимостями, предоставляя готовые наборы для типовых задач (`spring-boot-starter-web`, `spring-boot-starter-data-jpa`, `spring-boot-starter-security`). Достаточно добавить один стартер вместо множества отдельных библиотек.
    *   **Встроенные сервера:** Позволяет легко запускать веб-приложения как обычные JAR-файлы со встроенным сервером (Tomcat по умолчанию, Jetty, Undertow). Не требует развертывания WAR на внешнем сервере.
    *   **Production-ready features:** Готовые решения для метрик (`Actuator`), проверки состояния (`Health Checks`), внешней конфигурации.
*   **Отличие:** Spring Boot - это *способ* использования Spring Framework, который избавляет от большей части ручной настройки и конфигурации, позволяя быстро начать разработку. Он не заменяет Spring Framework, а дополняет и упрощает его.
*   **Spring Boot Autoconfiguration - Как работает (упрощенно):**
    1.  Spring Boot ищет файл `META-INF/spring.factories` (или `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` с Spring Boot 2.7+) в classpath.
    2.  В этих файлах перечислены классы автоконфигураций (`@Configuration`).
    3.  Каждый класс автоконфигурации использует аннотации `@Conditional...` (например, `@ConditionalOnClass`, `@ConditionalOnBean`, `@ConditionalOnProperty`) для проверки условий: есть ли нужный класс в classpath? есть ли уже созданный бин? есть ли определенное свойство?
    4.  Если условия выполняются, автоконфигурация создает и настраивает необходимые бины с разумными значениями по умолчанию. Эти значения можно переопределить в `application.properties/yml`.

### Spring Core (DI, IoC, Beans)

*   **IoC (Inversion of Control):** Принцип проектирования, при котором управление потоком выполнения программы и жизненным циклом объектов "инвертируется" - передается внешнему фреймворку (контейнеру) вместо того, чтобы объекты сами создавали и управляли своими зависимостями.
*   **DI (Dependency Injection):** Конкретная реализация IoC, при которой зависимости объекта (другие объекты, с которыми он взаимодействует) предоставляются ему извне (внедряются контейнером), а не создаются им самим.
*   **Bean:** Объект, жизненным циклом которого управляет Spring IoC контейнер (ApplicationContext). Spring создает бины, настраивает их, внедряет зависимости и управляет их областью видимости и уничтожением.
*   **ApplicationContext:** Центральный интерфейс Spring для доступа к IoC контейнеру. Предоставляет методы для получения бинов (`getBean()`) и другие возможности.
*   **Способы объявления бинов:**
    *   **Стереотипные аннотации:** `@Component` (базовая), `@Service` (бизнес-логика), `@Repository` (доступ к данным, добавляет трансляцию исключений), `@Controller`/`@RestController` (веб-слой). Spring сканирует classpath (`@ComponentScan`) и автоматически регистрирует классы с этими аннотациями как бины.
    *   **Java Configuration:** Использование классов с аннотацией `@Configuration` и методов с аннотацией `@Bean`. Метод `@Bean` возвращает объект, который регистрируется как бин. Позволяет более гибко настраивать создание бинов.
    *   **XML Configuration:** (Устаревающий способ) Описание бинов и их зависимостей в XML-файлах.
*   **Способы внедрения зависимостей:** Как Spring предоставляет одному бину ссылку на другой бин.
    1.  **Через конструктор (Constructor Injection):** **Рекомендуемый способ.** Зависимости объявляются как параметры конструктора. Spring находит нужные бины и передает их при создании объекта.
        *   **Плюсы:** Явно объявляет обязательные зависимости. Позволяет создавать immutable бины (поля `final`). Улучшает тестируемость (легко передать моки в конструктор). Гарантирует, что объект создается с валидными зависимостями.
        *   **Аннотация:** `@Autowired` над конструктором необязательна, если в классе только один конструктор (с Spring 4.3+).
    2.  **Через сеттер (Setter Injection):** Зависимости внедряются через вызов сеттер-методов, помеченных `@Autowired`.
        *   **Плюсы:** Позволяет внедрять опциональные зависимости. Может помочь разорвать циклические зависимости (хотя их лучше избегать рефакторингом).
        *   **Минусы:** Бин может существовать в не полностью инициализированном состоянии до вызова сеттера. Зависимости не обязательны (`final` поля использовать нельзя).
    3.  **Через поле (Field Injection):** Зависимости внедряются напрямую в поля, помеченные `@Autowired`.
        *   **Плюсы:** Самый лаконичный код.
        *   **Минусы:** **Не рекомендуется.** Нарушает инкапсуляцию. Затрудняет юнит-тестирование (нужна рефлексия или DI-контейнер для установки моков). Скрывает зависимости класса. Не позволяет использовать `final` поля.
*   **Жизненный цикл бина (упрощенно):**
    1.  **Инстанцирование:** Spring создает экземпляр класса бина (вызывает конструктор).
    2.  **Заполнение свойств (DI):** Spring внедряет все зависимости (через конструктор, сеттеры или поля).
    3.  **Aware-интерфейсы:** Если бин реализует `BeanNameAware`, `BeanFactoryAware`, `ApplicationContextAware` и т.д., вызываются соответствующие `set*` методы.
    4.  **`@PostConstruct` / `InitializingBean` / `init-method`:** Вызываются методы инициализации (в указанном порядке). `@PostConstruct` - предпочтительный современный способ.
    5.  **Бин готов к использованию.**
    6.  **`@PreDestroy` / `DisposableBean` / `destroy-method`:** При закрытии ApplicationContext вызываются методы уничтожения (в указанном порядке). `@PreDestroy` - предпочтительный способ. *Не вызывается для бинов с scope `prototype`.*
*   **Scope (Область видимости) бинов:** Определяет, сколько экземпляров бина будет создано и как долго они будут существовать. Задается через аннотацию `@Scope`.
    *   **`singleton` (по умолчанию):** Создается **один** экземпляр бина на весь ApplicationContext. Все запросы к этому бину возвращают один и тот же объект.
    *   **`prototype`:** Создается **новый** экземпляр бина при **каждом** запросе (`getBean()` или инъекции). Spring создает, настраивает и отдает бин, но **не управляет** его дальнейшим жизненным циклом (не вызывает `@PreDestroy`/destroy-методы). Ответственность за уничтожение ложится на клиентский код.
    *   **`request`:** (Веб-контекст) Один экземпляр на каждый HTTP-запрос.
    *   **`session`:** (Веб-контекст) Один экземпляр на каждую HTTP-сессию.
    *   **`application`:** (Веб-контекст) Один экземпляр на время жизни `ServletContext`.
    *   **`websocket`:** (Веб-контекст) Один экземпляр на время жизни WebSocket сессии.

### Spring Data

*   Проект Spring, упрощающий разработку слоя доступа к данным. Предоставляет абстракции для работы с различными хранилищами (реляционными БД через JPA, NoSQL базами типа MongoDB, Redis, Cassandra).
*   **Spring Data JPA:** Модуль для работы с JPA.
    *   **Repository (Репозиторий):** Основная концепция. Это интерфейс, который наследуется от `JpaRepository<EntityType, IdType>` (или `CrudRepository`, `PagingAndSortingRepository`).
    *   **Автоматическая генерация запросов:** Spring Data JPA автоматически генерирует реализацию методов репозитория на основе их **имен** (например, `findByName(String name)`, `findByAgeGreaterThan(int age)`) или с помощью аннотации `@Query` (для написания JPQL, HQL или нативного SQL).
    *   Упрощает CRUD операции, пагинацию и сортировку.

### Spring Web

*   Модуль Spring для создания веб-приложений и REST API (Spring MVC).
*   **Основные аннотации:**
    *   `@Controller`: Помечает класс как веб-контроллер (обычно для возврата имен представлений - view names).
    *   `@RestController`: Удобная аннотация, объединяющая `@Controller` и `@ResponseBody`. Указывает, что все методы контроллера по умолчанию возвращают данные, которые должны быть сериализованы в тело ответа (например, JSON), а не имена представлений.
    *   `@RequestMapping("/path")`: Маппинг HTTP-запросов на методы контроллера (на уровне класса или метода). Можно указать путь, HTTP-метод (`method = RequestMethod.GET`), параметры, заголовки.
    *   `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, `@PatchMapping`: Сокращенные версии `@RequestMapping` для конкретных HTTP-методов.
    *   `@PathVariable`: Для извлечения значений из URI-пути (`/users/{id}`).
    *   `@RequestParam`: Для извлечения параметров запроса из query string (`?name=value`) или данных формы.
    *   `@RequestBody`: Указывает, что параметр метода должен быть связан с телом HTTP-запроса (обычно десериализуется из JSON/XML).
    *   `@ResponseBody`: (Используется неявно в `@RestController`) Указывает, что возвращаемое значение метода должно быть сериализовано в тело HTTP-ответа.
    *   `ResponseEntity<T>`: Класс для полного контроля над HTTP-ответом (статус-код, заголовки, тело).
*   **Валидация входных данных в контроллере:**
    *   Используется стандарт **Bean Validation (JSR-380)**, реализация по умолчанию - **Hibernate Validator**.
    *   Поля в DTO (Data Transfer Object), принимаемом в `@RequestBody`, помечаются аннотациями валидации (`@NotNull`, `@NotEmpty`, `@NotBlank`, `@Size`, `@Min`, `@Max`, `@Email`, `@Pattern`, можно создавать кастомные).
    *   Параметр DTO в методе контроллера помечается аннотацией **`@Valid`** (из `javax.validation` или `jakarta.validation`) или **`@Validated`** (из Spring, позволяет использовать группы валидации).
    *   ```java
        @PostMapping("/items")
        public ResponseEntity<?> createItem(@Valid @RequestBody ItemDto itemDto, BindingResult bindingResult) {
            if (bindingResult.hasErrors()) {
                // Если есть ошибки валидации, собрать их и вернуть 400 Bad Request
                List<String> errors = bindingResult.getFieldErrors().stream()
                        .map(e -> e.getField() + ": " + e.getDefaultMessage())
                        .collect(Collectors.toList());
                return ResponseEntity.badRequest().body(errors);
            }
            // Валидация прошла успешно
            Item createdItem = itemService.create(itemDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdItem);
        }
        ```
*   **`BindingResult`:**
    *   Интерфейс Spring, который **должен идти непосредственно после** валидируемого параметра в сигнатуре метода контроллера.
    *   Он **собирает результаты валидации**. Если он присутствует, Spring **не** выбрасывает исключение `MethodArgumentNotValidException` при ошибках, а помещает информацию об ошибках в этот объект.
    *   Позволяет программно проверить наличие ошибок (`bindingResult.hasErrors()`) и получить детали (`bindingResult.getAllErrors()`, `bindingResult.getFieldErrors()`), чтобы сформировать кастомный ответ об ошибках.

### Spring AOP

*   **AOP (Aspect-Oriented Programming - Аспектно-ориентированное программирование):** Парадигма программирования, которая позволяет **модуляризировать сквозную функциональность (cross-cutting concerns)**. Это логика, которая затрагивает множество частей приложения (например, логирование, управление транзакциями, безопасность, кеширование), но не относится напрямую к основной бизнес-логике этих частей. AOP позволяет вынести эту логику в отдельные модули - **аспекты**.
*   **Основные понятия Spring AOP:**
    *   **Aspect (Аспект):** Класс, помеченный `@Aspect`, который инкапсулирует сквозную логику (советы и срезы).
    *   **Join Point (Точка соединения):** **Момент** в выполнении программы, куда можно встроить логику аспекта. В Spring AOP это **всегда выполнение метода**.
    *   **Advice (Совет):** **Действие**, выполняемое аспектом в определенной точке соединения. Код, который выполняется до, после, или вместо основного метода. Типы советов:
        *   `@Before`: Выполняется **перед** вызовом метода.
        *   `@AfterReturning`: Выполняется **после успешного** завершения метода (если не было исключения). Может получить доступ к возвращаемому значению.
        *   `@AfterThrowing`: Выполняется, если метод выбросил **исключение**. Может получить доступ к исключению.
        *   `@After`: Выполняется **после** завершения метода, **независимо** от того, было исключение или нет (аналог `finally`).
        *   `@Around`: Самый мощный тип. **Оборачивает** вызов метода. Может выполнить логику до и после вызова, изменить аргументы, возвращаемое значение, или даже пропустить вызов основного метода. Требует явного вызова `ProceedingJoinPoint.proceed()`.
    *   **Pointcut (Срез):** **Выражение**, которое определяет, **к каким** точкам соединения (методам) применять совет. Используется язык выражений AspectJ. Пример: `@Pointcut("execution(* com.example.service.*.*(..))")` - все методы во всех классах пакета `com.example.service`.
    *   **Target Object (Целевой объект):** Оригинальный объект (бин), к которому применяется логика аспекта.
    *   **Proxy (Прокси):** Объект, создаваемый Spring AOP во время выполнения, который **оборачивает** целевой объект. Вызовы методов сначала перехватываются прокси, который выполняет логику советов, а затем (если нужно) делегирует вызов оригинальному методу целевого объекта.
*   **Прокси-объекты в Spring AOP:** Spring создает прокси для бинов, к которым должны применяться аспекты.
    *   **JDK Dynamic Proxy:** Используется по умолчанию, если целевой бин реализует **хотя бы один интерфейс**. Прокси создается во время выполнения, реализует те же интерфейсы, что и целевой бин, и делегирует вызовы ему.
    *   **CGLIB Proxy:** Используется, если целевой бин **не реализует интерфейсы**. Прокси создается путем **наследования** от класса целевого бина и переопределения его методов. Требует наличия библиотеки CGLIB (включена в `spring-core`). Целевой класс и его методы не должны быть `final`.

### Транзакции в Spring

*   **Декларативное управление транзакциями:** Spring позволяет управлять транзакциями с помощью аннотации **`@Transactional`**, что избавляет от необходимости писать шаблонный код управления транзакциями вручную (`try/catch/finally`, `commit/rollback`).
*   **`@Transactional`:** Аннотация, которая может применяться к методам или классам. Указывает, что метод (или все публичные методы класса) должен выполняться в рамках транзакции БД.
*   **Как работает:** Использует Spring AOP. Spring создает **прокси** вокруг бина, помеченного `@Transactional`.
    1.  **Перед вызовом** метода прокси начинает новую транзакцию или присоединяется к существующей (в зависимости от `propagation`).
    2.  Выполняется **оригинальный метод** бина.
    3.  **Если метод завершается успешно:** Прокси выполняет **commit** транзакции.
    4.  **Если метод выбрасывает исключение:** Прокси выполняет **rollback** транзакции (по умолчанию для `RuntimeException` и `Error`, но не для checked `Exception`).
*   **Атрибуты `@Transactional`:**
    *   `propagation`: Определяет поведение метода, если он вызывается из контекста уже существующей транзакции. Основные значения:
        *   `REQUIRED` (по умолчанию): Использовать существующую транзакцию, если она есть; иначе создать новую.
        *   `REQUIRES_NEW`: Всегда создавать новую, независимую транзакцию (приостанавливая текущую, если она есть).
        *   `SUPPORTS`: Выполняться в текущей транзакции, если она есть; иначе выполняться без транзакции.
        *   `NOT_SUPPORTED`: Всегда выполняться без транзакции (приостанавливая текущую, если она есть).
        *   `MANDATORY`: Выполняться только в существующей транзакции; иначе выбросить исключение.
        *   `NEVER`: Всегда выполняться без транзакции; если есть текущая транзакция, выбросить исключение.
    *   `isolation`: Уровень изоляции транзакции (`READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`, `DEFAULT` - использовать уровень по умолчанию для БД).
    *   `readOnly`: Флаг (boolean, по умолчанию `false`). Если `true`, указывает СУБД и JPA провайдеру, что транзакция только для чтения (может применяться оптимизация).
    *   `timeout`: Таймаут транзакции в секундах.
    *   `rollbackFor`, `noRollbackFor`: Массивы классов исключений, которые должны (или не должны) приводить к откату транзакции, переопределяя поведение по умолчанию.
*   **Важно:** `@Transactional` работает только для вызовов методов **через прокси**. Вызов `@Transactional` метода из другого метода **того же** класса (`this.transactionalMethod()`) **не** будет перехвачен прокси, и новая транзакция (или ожидаемое поведение `propagation`) не начнется.

### Планировщик задач

*   Spring предоставляет удобный механизм для выполнения задач по расписанию.
*   **`@EnableScheduling`:** Аннотация, которую нужно добавить к одному из `@Configuration` классов, чтобы включить поддержку планировщика.
*   **`@Scheduled`:** Аннотация над методом (который должен быть в Spring бине, без аргументов, обычно `void`), указывающая, когда его нужно выполнять.
    *   `fixedRate`: Запускать периодически с фиксированным интервалом в миллисекундах **между началами** последовательных выполнений. Если выполнение задачи занимает больше времени, чем интервал, следующая начнется сразу после завершения предыдущей.
        ```java
        @Scheduled(fixedRate = 5000) // Каждые 5 секунд
        public void doSomething() { ... }
        ```
    *   `fixedDelay`: Запускать периодически с фиксированной задержкой в миллисекундах **между окончанием** предыдущего выполнения и **началом** следующего.
        ```java
        @Scheduled(fixedDelay = 10000) // Через 10 секунд после завершения предыдущего
        public void doSomethingElse() { ... }
        ```
    *   `initialDelay`: Начальная задержка в миллисекундах перед первым запуском (используется с `fixedRate` или `fixedDelay`).
    *   `cron`: Запускать по cron-выражению, которое задает сложное расписание (секунды, минуты, часы, день месяца, месяц, день недели).
        ```java
        @Scheduled(cron = "0 15 10 * * MON-FRI") // В 10:15 каждый будний день
        public void generateReport() { ... }
        ```

### Spring Security

*   Мощный и гибкий фреймворк для обеспечения безопасности Spring-приложений (аутентификация и авторизация).
*   **Основные концепции (очень упрощенно):**
    *   **Authentication (Аутентификация):** Проверка личности пользователя (кто ты?). Процесс подтверждения, что пользователь является тем, за кого себя выдает (обычно через логин/пароль, токен, сертификат). Результат - объект `Authentication`, содержащий информацию о пользователе (`Principal`) и его правах (`GrantedAuthority`).
    *   **Authorization (Авторизация):** Проверка прав доступа аутентифицированного пользователя к определенному ресурсу или действию (что тебе можно делать?). Основывается на ролях (`hasRole('ADMIN')`) или правах (`hasAuthority('READ_PRIVILEGE')`).
    *   **SecurityContextHolder:** Хранит информацию о текущем аутентифицированном пользователе (`Authentication`) в `ThreadLocal` переменной.
    *   **FilterChainProxy (Цепочка фильтров безопасности):** Основа Spring Security для веб-приложений. Все входящие запросы проходят через цепочку стандартных фильтров (`SecurityFilter`), каждый из которых выполняет определенную задачу (обработка аутентификации по сессии, basic auth, JWT токену; проверка CSRF; применение правил авторизации и т.д.).
    *   **Конфигурация:** Обычно выполняется через Java Configuration (класс, наследующий `WebSecurityConfigurerAdapter` до Spring Security 5.7, или через определение бина `SecurityFilterChain` с версии 5.7+).

### Spring Profiles

*   Механизм Spring, позволяющий регистрировать разные бины или применять разные конфигурации в зависимости от **активного профиля**.
*   Профили - это строки-идентификаторы (например, `dev`, `test`, `prod`, `cloud`).
*   **Применение:**
    *   Аннотация `@Profile("profileName")` над `@Configuration` классом или `@Bean` методом. Бин будет создан только если указанный профиль активен.
    *   Использование файлов свойств `application-{profile}.properties` (или `.yml`). Свойства из активного профильного файла переопределяют свойства из `application.properties`.
*   **Активация профиля:**
    *   Через свойство `spring.profiles.active=dev,h2` (в `application.properties`, как параметр JVM `-Dspring.profiles.active=...`, как переменную окружения `SPRING_PROFILES_ACTIVE=...`).
    *   Программно через `ApplicationContext`.
    *   Через аннотацию `@ActiveProfiles` в тестах.

---

## Микросервисы и Распределенные системы

### Архитектурные стили

*   **Монолит:** Все приложение развернуто как единый, неделимый модуль (например, один WAR или JAR файл). Компоненты (UI, бизнес-логика, доступ к данным) тесно связаны внутри одного процесса.
    *   ✅ **Простота:** Легче разрабатывать, тестировать, развертывать и отлаживать на начальных этапах. Единая кодовая база. Локальные вызовы методов быстрые. Транзакции обычно локальные (ACID).
    *   ❌ **Масштабирование:** Сложно масштабировать отдельные компоненты независимо. Нужно масштабировать все приложение целиком.
    *   ❌ **Технологии:** Привязка к одному технологическому стеку. Сложно внедрять новые технологии.
    *   ❌ **Надежность:** Ошибка в одном компоненте может повлиять на все приложение ("единая точка отказа").
    *   ❌ **Разработка:** С ростом кодовой базы сложность увеличивается, время сборки и запуска растет, команды могут мешать друг другу.
*   **Микросервисы:** Приложение построено как набор небольших, **независимо развертываемых** сервисов. Каждый сервис реализует определенную бизнес-возможность, имеет свою базу данных (часто) и общается с другими сервисами по сети (обычно через HTTP/REST или асинхронные сообщения).
    *   ✅ **Независимость:** Сервисы можно разрабатывать, тестировать, развертывать и масштабировать независимо друг от друга разными командами.
    *   ✅ **Технологии:** Возможность использовать разные технологии и языки для разных сервисов.
    *   ✅ **Надежность:** Отказ одного сервиса (если система спроектирована правильно) не должен приводить к отказу всего приложения. Изоляция сбоев.
    *   ✅ **Масштабируемость:** Можно масштабировать только те сервисы, которые испытывают высокую нагрузку.
    *   ❌ **Сложность:** Распределенная система inherently сложнее монолита. Сетевые вызовы (задержки, ошибки). Распределенные транзакции. Согласованность данных. Мониторинг и отладка сложнее.
    *   ❌ **Инфраструктура:** Требует более сложной инфраструктуры для развертывания, управления, мониторинга (контейнеризация, оркестрация, Service Discovery, API Gateway).
    *   ❌ **Тестирование:** Интеграционное тестирование становится сложнее.

### Коммуникация

*   **Синхронная:** Клиент (вызывающий сервис) отправляет запрос и **блокируется**, ожидая ответа от другого сервиса.
    *   **REST (HTTP):** Самый распространенный стиль. Использует стандартные HTTP методы (GET, POST, PUT, DELETE), URI для идентификации ресурсов и обычно JSON для передачи данных. Простой, понятный, легко тестируемый. Stateless (сервер не хранит состояние клиента между запросами).
    *   **gRPC:** Фреймворк RPC (Remote Procedure Call) от Google. Использует HTTP/2 для транспорта (эффективный, поддерживает мультиплексирование, стриминг) и Protocol Buffers (Protobuf) для сериализации данных (бинарный, компактный, быстрый). Определяет контракт API через `.proto` файлы (IDL - Interface Definition Language), из которых генерируется код клиента и сервера. Производительный, подходит для внутренних коммуникаций. Поддерживает потоковую передачу (unary, server streaming, client streaming, bidirectional streaming).
    *   **SOAP (Simple Object Access Protocol):** Протокол обмена сообщениями на основе **XML**. Работает поверх различных транспортов (HTTP, SMTP). Более строгий и формальный, чем REST. Использует **WSDL** (Web Services Description Language) для описания контракта сервиса и **XSD** (XML Schema Definition) для описания структуры данных. Часто используется в legacy enterprise-системах. Поддерживает стандарты WS-* (WS-Security, WS-ReliableMessaging).
*   **Асинхронная (Event-Driven):** Сервисы общаются через **сообщения** или **события**, не ожидая немедленного ответа. Продюсер отправляет сообщение, консюмер получает и обрабатывает его в удобное время. Повышает **слабую связанность (loose coupling)** и **отказоустойчивость**.
    *   **Очереди сообщений / Брокеры сообщений:** Промежуточное ПО (Message Broker), которое принимает сообщения от продюсеров и доставляет их консюмерам. Примеры:
        *   **Kafka:** Распределенная платформа для потоковой передачи событий. Оптимизирована для высокой пропускной способности и обработки потоков данных в реальном времени. Использует модель pub/sub с топиками и партициями.
        *   **RabbitMQ:** Традиционный брокер сообщений, реализующий протокол AMQP. Поддерживает различные модели обмена (point-to-point, pub/sub, routing). Гибкий в настройке маршрутизации.
        *   **ActiveMQ:** Еще один популярный брокер с поддержкой JMS, AMQP, MQTT.

### Паттерны координации

Как управлять потоком выполнения бизнес-процесса, затрагивающего несколько микросервисов.
*   **Оркестрация (Orchestration):** Существует **центральный** компонент (оркестратор), который **явно управляет** процессом. Оркестратор знает шаги процесса и вызывает нужные сервисы в нужной последовательности, ожидает их ответы, обрабатывает ошибки и принимает решения о дальнейших действиях. Похоже на дирижера в оркестре.
    *   ✅ **Явный контроль:** Бизнес-логика процесса централизована и понятна. Легче отслеживать состояние процесса и обрабатывать ошибки.
    *   ❌ **Сильная связанность:** Сервисы зависят от оркестратора, а оркестратор знает о всех сервисах. Оркестратор может стать "узким горлышком" и единой точкой отказа.
    *   Инструменты: Camunda, Temporal, Apache Airflow, AWS Step Functions.
*   **Хореография (Choreography):** **Нет** центрального координатора. Каждый сервис выполняет свою часть работы и **публикует события** о том, что он сделал. Другие сервисы **подписываются** на интересующие их события и реагируют на них, выполняя свою работу и, возможно, публикуя новые события. Похоже на танцоров, которые знают свою партию и реагируют на музыку и движения других.
    *   ✅ **Слабая связанность:** Сервисы не знают друг о друге напрямую, только о событиях. Легко добавлять/изменять сервисы. Система более гибкая и отказоустойчивая.
    *   ❌ **Сложность отслеживания:** Трудно понять и отладить сквозной бизнес-процесс, так как логика распределена по многим сервисам. Возможны циклические зависимости событий.
    *   Технологии: Брокеры сообщений (Kafka, RabbitMQ).

### Распределенные транзакции

Обеспечение атомарности операций, затрагивающих несколько сервисов (и их баз данных). Стандартные ACID-транзакции не работают между сервисами.
*   **Two-Phase Commit (2PC - Двухфазный коммит):** Протокол, требующий **координатора** транзакций.
    1.  **Фаза 1 (Prepare):** Координатор отправляет запрос "Prepare" всем участвующим сервисам (ресурсам). Каждый участник выполняет свою часть работы, блокирует ресурсы и отвечает "Готов" (prepared) или "Не готов" (aborted).
    2.  **Фаза 2 (Commit/Rollback):**
        *   Если **все** участники ответили "Готов", координатор отправляет команду "Commit". Участники фиксируют изменения и освобождают ресурсы.
        *   Если **хотя бы один** ответил "Не готов" или не ответил (таймаут), координатор отправляет команду "Rollback". Участники откатывают изменения и освобождают ресурсы.
    *   ✅ **Гарантирует строгую атомарность (ACID).**
    *   ❌ **Блокирующий:** Участники держат блокировки с фазы Prepare до фазы Commit/Rollback, что снижает производительность и доступность.
    *   ❌ **Координатор - точка отказа:** Если координатор падает между фазами, система может зависнуть в неопределенном состоянии.
    *   ❌ **Плохо масштабируется.** Редко используется в современных микросервисных архитектурах из-за проблем с производительностью и доступностью.
*   **Saga:** Паттерн для управления согласованностью данных в распределенных системах **без** использования распределенных блокировок (как в 2PC). Достигает **итоговой согласованности (eventual consistency)**.
    *   **Как работает:** Длинная бизнес-транзакция разбивается на последовательность **локальных транзакций** в каждом участвующем сервисе. Каждая локальная транзакция обновляет данные в своем сервисе и публикует событие (или отправляет команду следующему сервису).
    *   **Компенсация:** Если какая-либо локальная транзакция завершается неудачей, Saga выполняет **компенсирующие транзакции** в обратном порядке, чтобы отменить изменения, сделанные предыдущими успешными шагами. Компенсирующая транзакция должна быть идемпотентной.
    *   **Реализация:**
        *   **Хореография:** Сервисы координируются через обмен событиями. Каждый сервис слушает события и запускает свою локальную транзакцию и/или компенсирующую транзакцию.
        *   **Оркестрация:** Центральный Saga-оркестратор управляет последовательностью выполнения локальных транзакций и вызывает компенсирующие транзакции при сбое.
    *   ✅ **Неблокирующий:** Локальные транзакции короткие, ресурсы не блокируются надолго. Повышает доступность и производительность.
    *   ❌ **Сложнее в реализации:** Нужно тщательно проектировать компенсирующие транзакции.
    *   ❌ **Нет полной атомарности и изоляции:** Возможны промежуточные несогласованные состояния. Обеспечивает только итоговую согласованность.
    *   ❌ **Сложность отладки.**

### API Gateway и Балансировка

*   **API Gateway:** Сервис, который выступает **единой точкой входа (single entry point)** для всех внешних клиентов (веб-приложения, мобильные приложения, сторонние сервисы) в систему микросервисов.
    *   **Задачи:**
        *   **Маршрутизация (Routing):** Направляет входящие запросы к соответствующим микросервисам.
        *   **Агрегация (Aggregation):** Может объединять результаты от нескольких микросервисов в один ответ для клиента.
        *   **Аутентификация и Авторизация:** Централизованная проверка учетных данных и прав доступа.
        *   **Rate Limiting:** Ограничение частоты запросов от клиентов.
        *   **Кеширование:** Кеширование ответов от микросервисов.
        *   **Преобразование протоколов:** Например, прием REST запросов и их преобразование в gRPC для внутренних сервисов.
        *   **Мониторинг и Логирование:** Централизованный сбор метрик и логов запросов.
        *   **Балансировка нагрузки:** Может распределять запросы между несколькими экземплярами одного микросервиса.
    *   Примеры: Spring Cloud Gateway, Netflix Zuul, Kong, Apigee.
*   **Load Balancer (Балансировщик нагрузки):** Устройство или ПО, которое **распределяет** входящий сетевой трафик (например, HTTP запросы) между **несколькими серверами (экземплярами)**, выполняющими одну и ту же функцию.
    *   **Цели:**
        *   **Повышение производительности и пропускной способности:** Распределение нагрузки позволяет обрабатывать больше запросов.
        *   **Обеспечение отказоустойчивости и высокой доступности:** Если один сервер выходит из строя, балансировщик перенаправляет трафик на работающие.
        *   **Упрощение масштабирования:** Легко добавлять/удалять серверы за балансировщиком.
    *   **Алгоритмы балансировки:**
        *   **Round Robin:** Запросы распределяются по серверам поочередно, по кругу.
        *   **Least Connections:** Запрос направляется на сервер с наименьшим количеством активных соединений в данный момент.
        *   **IP Hash:** Сервер выбирается на основе хэша IP-адреса клиента (обеспечивает "липкие сессии" - запросы от одного клиента попадают на один и тот же сервер).
        *   **Random:** Случайный выбор сервера.
    *   **Уровни балансировки:** L4 (TCP/UDP, на основе IP/порта), L7 (HTTP, на основе URL, заголовков, cookies). API Gateway часто работает как L7 балансировщик.

### Messaging (Kafka)

*   **Что такое Kafka:** Распределенная, отказоустойчивая, горизонтально масштабируемая платформа для **потоковой передачи событий (event streaming)**. Работает как **распределенный журнал фиксации (distributed commit log)**. Используется для построения конвейеров данных реального времени, интеграции приложений, event-driven архитектур.
*   **Основные компоненты:**
    *   **Broker:** Сервер Kafka. Хранит данные (партиции топиков). Кластер Kafka состоит из нескольких брокеров для отказоустойчивости и масштабируемости.
    *   **Topic (Топик):** Именованная категория или поток записей (сообщений). Продюсеры публикуют сообщения в топики, консюмеры подписываются на топики для чтения.
    *   **Partition (Партиция):** Топик делится на одну или несколько партиций. Каждая партиция - это **упорядоченный, неизменяемый (append-only)** лог сообщений. Партиции позволяют распараллелить хранение и обработку данных топика. Сообщения внутри **одной** партиции хранятся и доставляются консюмерам **в порядке их поступления**. Порядок между разными партициями не гарантируется.
    *   **Offset:** Уникальный последовательный номер (ID) сообщения внутри партиции. Консюмеры отслеживают свой offset для каждой партиции, чтобы знать, какие сообщения уже прочитаны.
    *   **Producer:** Приложение, которое публикует (пишет) сообщения в один или несколько топиков Kafka. Продюсер может выбирать, в какую партицию отправлять сообщение (по ключу или round-robin).
    *   **Consumer:** Приложение, которое подписывается на один или несколько топиков и читает (потребляет) из них сообщения.
    *   **Consumer Group:** Группа консюмеров, которые совместно читают из одного или нескольких топиков для распределения нагрузки и отказоустойчивости. Kafka гарантирует, что каждое сообщение из партиции будет доставлено **только одному** консюмеру **внутри** одной Consumer Group. Если добавить больше консюмеров в группу (до числа партиций), нагрузка будет распределяться между ними.
    *   **ZooKeeper:** (Обязателен до Kafka 2.8, опционален с KRaft) Внешняя система, используемая Kafka для хранения метаданных кластера (информация о брокерах, топиках, партициях, конфигурации, ACL).
*   **Преимущества Kafka:**
    *   **Высокая пропускная способность:** Способна обрабатывать миллионы сообщений в секунду.
    *   **Масштабируемость:** Легко масштабируется горизонтально добавлением брокеров и партиций.
    *   **Отказоустойчивость:** Данные реплицируются между брокерами (настраиваемый фактор репликации).
    *   **Долговечность:** Сообщения сохраняются на диске и могут храниться длительное время (настраиваемый retention period).
    *   ** decoupled / Слабая связанность:** Продюсеры и консюмеры не зависят друг от друга.
    *   **Порядок сообщений:** Гарантируется в пределах одной партиции.
    *   **Возможность повторного чтения:** Консюмеры могут перечитывать сообщения, управляя своим offset.

### Паттерны отказоустойчивости

*   **Circuit Breaker (Автоматический выключатель):** Паттерн, предотвращающий повторные вызовы сервиса, который испытывает проблемы (медленно отвечает или возвращает ошибки).
    *   **Состояния:**
        *   **Closed (Замкнут):** Запросы проходят к сервису. Статистика ошибок собирается.
        *   **Open (Разомкнут):** Если количество ошибок превышает порог, выключатель "размыкается". Запросы к сервису **немедленно отклоняются** (fail fast) без попытки вызова.
        *   **Half-Open (Полуоткрыт):** Через некоторое время выключатель переходит в это состояние. Пропускается **один** (или несколько) тестовых запросов к сервису. Если он успешен - выключатель замыкается (Closed). Если нет - снова размыкается (Open).
    *   **Цель:** Дать проблемному сервису время на восстановление, избежать лавинообразных отказов, быстро возвращать ошибку клиенту.
    *   **Реализации:** Netflix Hystrix (устарел), Resilience4j, Spring Cloud Circuit Breaker.
*   **Retry (Повторные попытки):** Автоматическое повторение неудавшегося вызова к другому сервису через некоторое время. Помогает справиться с кратковременными сетевыми сбоями или временной недоступностью сервиса. Важно использовать с осторожностью (ограниченное число попыток, экспоненциальная задержка - exponential backoff), чтобы не усугубить проблему.
*   **Timeout:** Установка максимального времени ожидания ответа от другого сервиса. Предотвращает бесконечное зависание потока в ожидании ответа.
*   **Bulkhead (Переборка):** Изоляция сбоев. Ограничение ресурсов (например, потоков в пуле), выделенных для вызова определенного сервиса, чтобы его проблемы не повлияли на вызовы других сервисов.

### Вспомогательные паттерны

*   **Service Discovery (Обнаружение сервисов):** В динамической среде микросервисов экземпляры сервисов постоянно появляются и исчезают, их сетевые адреса (IP, порт) меняются. Service Discovery - это механизм, позволяющий сервисам **автоматически находить** сетевые координаты других сервисов, к которым им нужно обратиться.
    *   **Компоненты:**
        *   **Service Registry (Реестр сервисов):** Централизованная база данных, хранящая информацию о доступных экземплярах сервисов и их адресах (например, Eureka, Consul, ZooKeeper).
        *   **Регистрация:** Экземпляры сервисов при старте регистрируются в реестре, сообщая свой адрес и статус.
        *   **Обнаружение:** Клиентские сервисы запрашивают у реестра адрес нужного им сервиса.
    *   **Типы:** Client-Side Discovery (клиент сам запрашивает реестр и выбирает экземпляр), Server-Side Discovery (клиент обращается к роутеру/балансировщику, который запрашивает реестр).
*   **Configuration Management (Управление конфигурацией):** Микросервисам требуется множество конфигурационных параметров (адреса БД, ключи API, таймауты и т.д.), которые могут отличаться в разных окружениях. Необходим механизм для **централизованного хранения и управления** этими конфигурациями.
    *   **Преимущества:** Изменение конфигурации без пересборки/переразвертывания сервисов, управление конфигурацией для разных окружений, версионирование конфигурации.
    *   **Инструменты:** Spring Cloud Config Server, Consul, etcd, HashiCorp Vault (для секретов).

---

## Контейнеризация и Оркестрация

### Docker

*   **Что такое:** Платформа с открытым исходным кодом для **автоматизации развертывания, масштабирования и управления приложениями** с использованием **контейнеризации**. Позволяет упаковать приложение и все его зависимости (библиотеки, системные утилиты, код) в легковесный, переносимый **контейнер**, который может работать практически где угодно.
*   **Основные концепции:**
    *   **Image (Образ):** Шаблон **только для чтения** с инструкциями для создания контейнера. Содержит слои файловой системы с приложением и его зависимостями. Образы создаются из `Dockerfile`.
    *   **Dockerfile:** Текстовый файл, содержащий **инструкции** по сборке Docker-образа (`FROM`, `COPY`, `RUN`, `WORKDIR`, `EXPOSE`, `CMD`, `ENTRYPOINT` и т.д.).
    *   **Container (Контейнер):** Запущенный, **исполняемый экземпляр** Docker-образа. Контейнеры изолированы друг от друга и от хост-системы на уровне процессов и файловой системы (используют namespaces и cgroups ядра Linux).
    *   **Docker Hub:** Публичный **репозиторий (registry)** Docker-образов по умолчанию. Можно хранить образы и в приватных репозиториях (Docker Trusted Registry, AWS ECR, Google GCR, Harbor).
    *   **Volume (Том):** Механизм для **сохранения данных**, генерируемых или используемых контейнером, **вне** файловой системы самого контейнера. Данные в volume сохраняются даже после удаления контейнера. Позволяет шарить данные между контейнерами или между контейнером и хостом. Предпочтительный способ для работы с персистентными данными (базы данных, логи).
    *   **Network:** Docker позволяет создавать виртуальные сети для изоляции и связи контейнеров. Контейнеры в одной сети могут обращаться друг к другу по **имени контейнера**.
*   **Docker Compose:** Инструмент для **определения и запуска многоконтейнерных** Docker-приложений.
    *   Использует **YAML-файл (`docker-compose.yml`)** для описания сервисов (контейнеров), сетей, томов, зависимостей между ними.
    *   Позволяет одной командой (`docker-compose up`) поднять всю инфраструктуру приложения (например, веб-сервер, базу данных, кэш).
    *   Упрощает настройку связей между контейнерами и управление всем приложением как единым целым в среде разработки и тестирования.
*   **Доступ к сервису внутри контейнера:**
    *   **Проброс портов (`docker run -p <host_port>:<container_port> ...` или `ports: ["<host_port>:<container_port>"]` в Compose):** Делает порт, на котором слушает приложение внутри контейнера, доступным на указанном порту хост-машины.
    *   **Через Docker Network:** Если контейнеры находятся в одной Docker-сети (по умолчанию в Compose создается сеть), они могут обращаться друг к другу по **имени сервиса**, указанному в `docker-compose.yml`, и порту контейнера (например, `http://my-db-service:5432`).

### Kubernetes (K8s)

*   **Что такое:** Платформа с открытым исходным кодом для **оркестрации контейнеров**. Автоматизирует развертывание, масштабирование, управление и обеспечение отказоустойчивости контейнеризированных приложений в кластерной среде. Стандарт де-факто для запуска контейнеров в production.
*   **Основные концепции (очень кратко):**
    *   **Node (Узел):** Физическая или виртуальная машина в кластере Kubernetes, на которой запускаются контейнеры.
    *   **Pod:** Минимальная развертываемая единица в Kubernetes. Представляет собой группу из **одного или нескольких** тесно связанных контейнеров, которые разделяют ресурсы хранения (Volumes) и сеть (IP-адрес). Обычно один Pod - один экземпляр приложения.
    *   **Service:** Абстракция, определяющая **логический набор Pod'ов** и политику доступа к ним. Предоставляет **стабильный IP-адрес и DNS-имя** для доступа к Pod'ам (которые могут пересоздаваться с новыми IP). Реализует балансировку нагрузки между Pod'ами. Типы: `ClusterIP` (внутренний доступ), `NodePort` (доступ через порт узла), `LoadBalancer` (интеграция с облачным балансировщиком), `ExternalName`.
    *   **Deployment:** Контроллер, который декларативно описывает **желаемое состояние** для Pod'ов (например, "всегда должно быть запущено 3 реплики моего приложения с образом X версии Y"). Kubernetes автоматически поддерживает это состояние, создавая, обновляя или удаляя Pod'ы. Обеспечивает **обновления (rolling updates)** и откаты.
    *   **Namespace:** Механизм для логического разделения ресурсов кластера (например, по проектам, командам или окружениям).
    *   **Ingress:** Объект API, который управляет **внешним доступом** к сервисам в кластере, обычно HTTP/HTTPS. Предоставляет маршрутизацию на основе хоста или пути, SSL/TLS-терминацию и балансировку нагрузки (реализуется через Ingress Controller, например, Nginx Ingress, Traefik).

---

## Инструменты и Сборка

### Maven

*   **Что такое:** Инструмент для **автоматизации сборки** Java-проектов и **управления зависимостями**. Использует декларативный подход на основе **XML-файла `pom.xml`** (Project Object Model).
*   **Основные задачи:** Компиляция кода, управление зависимостями (загрузка JAR-файлов из репозиториев), запуск тестов, упаковка проекта (в JAR, WAR), развертывание артефактов.
*   **`pom.xml`:** Содержит информацию о проекте (координаты GAV - GroupId, ArtifactId, Version), зависимости (`<dependencies>`), плагины (`<build><plugins>`), репозитории, профили и т.д.
*   **Жизненный цикл сборки (Build Lifecycle):** Предопределенная последовательность **фаз (phases)**. Основные фазы стандартного цикла (`default`):
    *   `validate`: Проверка корректности проекта.
    *   `compile`: Компиляция исходного кода (`src/main/java`).
    *   `test`: Компиляция и запуск юнит-тестов (`src/test/java`).
    *   `package`: Упаковка скомпилированного кода и ресурсов в дистрибутивный формат (JAR, WAR).
    *   `verify`: Выполнение проверок интеграционных тестов (если настроены).
    *   `install`: Установка артефакта проекта в **локальный репозиторий Maven** (`~/.m2/repository`), делая его доступным для других локальных проектов.
    *   `deploy`: Копирование артефакта в **удаленный репозиторий** (например, Nexus, Artifactory), делая его доступным для других разработчиков и сборочных систем.
*   **Phase vs Goal:**
    *   **Phase (Фаза):** Этап в жизненном цикле (например, `compile`, `test`, `package`). Сами фазы ничего не делают.
    *   **Goal (Цель):** Конкретная **задача**, выполняемая **плагином** Maven. Цели привязываются к фазам жизненного цикла. Например, цель `compiler:compile` плагина `maven-compiler-plugin` привязана к фазе `compile`. Вызов фазы (`mvn compile`) приводит к выполнению всех целей, привязанных к этой фазе и всем предыдущим фазам. Можно вызывать и конкретную цель напрямую (`mvn dependency:tree`).
*   **Scope зависимостей (`<scope>` в `<dependency>`):** Определяет, на каких этапах сборки и выполнения доступна зависимость и включается ли она в итоговый артефакт.
    *   **`compile` (по умолчанию):** Зависимость доступна на всех этапах (компиляция, тест, runtime). Включается в итоговый артефакт.
    *   **`provided`:** Зависимость необходима для компиляции и тестирования, но **ожидается**, что она будет предоставлена средой выполнения (JDK, контейнер сервлетов, например `servlet-api`). **Не включается** в итоговый артефакт.
    *   **`runtime`:** Зависимость не нужна для компиляции, но **нужна во время выполнения** (например, JDBC-драйвер). Включается в итоговый артефакт.
    *   **`test`:** Зависимость нужна только для компиляции и запуска тестов (например, JUnit, Mockito). **Не включается** в итоговый артефакт.
    *   **`system`:** Похожа на `provided`, но нужно явно указать путь к JAR файлу на диске (`<systemPath>`). **Не рекомендуется**, так как нарушает переносимость сборки.
    *   **`import`:** Используется только в секции `<dependencyManagement>`. Позволяет импортировать зависимости (их версии и scope) из другого POM-файла типа `pom` (обычно называется BOM - Bill of Materials).
*   **Транзитивные зависимости:** Maven автоматически загружает зависимости, необходимые вашим прямым зависимостям (и так далее). Управляет конфликтами версий (обычно выбирает "ближайшую" версию).

### Git

*   **Что такое:** **Распределенная система контроля версий (DVCS)**. Позволяет отслеживать изменения в файлах проекта, возвращаться к предыдущим версиям, работать над разными функциями параллельно (ветвление) и совместно с другими разработчиками.
*   **Основные команды:**
    *   `git init`: Инициализация нового репозитория.
    *   `git clone <url>`: Клонирование удаленного репозитория.
    *   `git status`: Показать состояние файлов (отслеживаемые, измененные, неиндексированные).
    *   `git add <file>` / `git add .`: Добавить изменения файла(ов) в индекс (staging area) для следующего коммита.
    *   `git commit -m "Сообщение коммита"`: Зафиксировать проиндексированные изменения в локальном репозитории.
    *   `git log`: Показать историю коммитов.
    *   `git branch`: Показать список веток / создать новую ветку.
    *   `git checkout <branch>` / `git switch <branch>`: Переключиться на другую ветку.
    *   `git checkout -b <new_branch>` / `git switch -c <new_branch>`: Создать новую ветку и переключиться на нее.
    *   `git merge <branch>`: Слить изменения из указанной ветки в **текущую** ветку. Создает новый **коммит слияния** (merge commit), если истории разошлись. Сохраняет обе истории ветвления.
    *   `git rebase <branch>`: Переместить (перебазировать) коммиты **текущей** ветки "поверх" последних изменений указанной (`<branch>`) ветки. **Переписывает историю** коммитов текущей ветки, делая ее линейной. Результат чище, но **нельзя использовать для публичных веток**, которые уже были отправлены в удаленный репозиторий.
    *   `git fetch`: Загрузить изменения (новые ветки, коммиты) из удаленного репозитория, **не** применяя их к локальной рабочей копии.
    *   `git pull`: = `git fetch` + `git merge` (по умолчанию) или `git fetch` + `git rebase` (если настроено). Загружает изменения и **сразу применяет** их к текущей локальной ветке.
    *   `git push`: Отправить локальные коммиты (текущей ветки) в удаленный репозиторий.
*   **Специальные команды:**
    *   **`git stash`:** Временно **сохраняет** незакоммиченные изменения (как измененные файлы, так и проиндексированные), чтобы **очистить** рабочую директорию (вернуться к состоянию HEAD). Позволяет быстро переключиться на другую ветку, не коммитя незаконченную работу.
        *   `git stash save "message"`: Сохранить с сообщением.
        *   `git stash list`: Показать список сохраненных состояний.
        *   `git stash pop`: Применить последнее сохраненное состояние и удалить его из списка.
        *   `git stash apply`: Применить последнее сохраненное состояние, но **не** удалять его из списка.
    *   **`git cherry-pick <commit_hash>`:** Применить **копию** изменений из указанного коммита (из другой ветки) в **текущую** ветку. Создает новый коммит с теми же изменениями. Полезно для переноса конкретных исправлений между ветками.

### CI/CD

*   **CI (Continuous Integration - Непрерывная Интеграция):** Практика разработки, при которой разработчики **часто** (несколько раз в день) интегрируют свои изменения кода в **общий репозиторий** (например, `main` или `develop` ветку). После каждого слияния автоматически запускается **сборка** проекта и **набор тестов** (юнит, интеграционные) для быстрого обнаружения и исправления ошибок интеграции.
*   **CD (Continuous Delivery - Непрерывная Поставка):** Расширение CI. Гарантирует, что **любая версия** кода, успешно прошедшая все автоматические тесты и проверки в CI пайплайне, **готова к развертыванию** на production (или другое окружение) **в любой момент**. Сам процесс развертывания на production может запускаться вручную (по кнопке). Цель - минимизировать риски релиза.
*   **CD (Continuous Deployment - Непрерывное Развертывание):** Следующий шаг после Continuous Delivery. Каждое изменение, успешно прошедшее все этапы CI/CD пайплайна (сборка, все тесты), **автоматически развертывается** на **production** без ручного вмешательства.
*   **CI/CD Pipeline (Конвейер):** Автоматизированная последовательность шагов для выполнения процессов CI/CD. Типичные этапы:
    1.  **Commit:** Разработчик отправляет код в систему контроля версий (Git).
    2.  **Build:** CI-сервер запускает сборку проекта (Maven, Gradle).
    3.  **Test:** Автоматический запуск тестов (юнит, интеграционные, статический анализ кода).
    4.  **Package/Artifact:** Создание артефакта (JAR, WAR, Docker-образ).
    5.  **Deploy to Staging:** Автоматическое развертывание на тестовое/staging окружение.
    6.  **Acceptance Tests:** Запуск автоматических приемочных тестов (UI-тесты, API-тесты) на staging.
    7.  **(Manual Approval for Delivery):** (Для Continuous Delivery) Ручное подтверждение релиза.
    8.  **Deploy to Production:** (Автоматически для Continuous Deployment, вручную для Delivery) Развертывание на продакшен.
*   **Инструменты:** Jenkins (популярный open-source CI/CD сервер), GitLab CI/CD, GitHub Actions, TeamCity, CircleCI, Travis CI.

---

## Тестирование

*   **Модульное тестирование (Unit Testing):**
    *   **Цель:** Проверка **корректности работы отдельных, изолированных** модулей (юнитов) программы, чаще всего - публичных методов классов.
    *   **Характеристики:**
        *   **Изоляция:** Тестируемый юнит изолируется от своих зависимостей с помощью **заглушек (stubs)** или **моков (mocks)**.
        *   **Скорость:** Выполняются очень быстро (миллисекунды).
        *   **Автоматизация:** Легко автоматизируются и встраиваются в CI пайплайн.
        *   **Фокус:** Проверка логики конкретного метода при различных входных данных и состояниях.
    *   **Инструменты:**
        *   **Фреймворки:** JUnit (самый популярный), TestNG.
        *   **Мокито (Mockito):** Библиотека для создания моков и стабов зависимостей.
        *   **AssertJ, Hamcrest:** Библиотеки для написания более читаемых и гибких утверждений (assertions).
*   **Интеграционное тестирование (Integration Testing):**
    *   **Цель:** Проверка **взаимодействия между несколькими компонентами** системы или между системой и внешними зависимостями (база данных, файловая система, другие сервисы).
    *   **Характеристики:**
        *   **Взаимодействие:** Тестирует совместную работу модулей (например, контроллер -> сервис -> репозиторий -> БД).
        *   **Окружение:** Часто требует более сложной настройки окружения (поднятие БД, запуск других сервисов).
        *   **Скорость:** Выполняются медленнее, чем юнит-тесты (секунды, иногда минуты).
        *   **Фокус:** Проверка корректности обмена данными, соблюдения контрактов, обработки ошибок на стыках компонентов.
    *   **Инструменты:**
        *   **Spring Test:** Модуль Spring для поддержки интеграционного тестирования (`@SpringBootTest`, `@DataJpaTest`, `@WebMvcTest`, `MockMvc`).
        *   **Testcontainers:** Библиотека Java, позволяющая **запускать Docker-контейнеры** (например, PostgreSQL, Kafka, Redis) **прямо из тестов**. Управляет их жизненным циклом. Позволяет тестировать взаимодействие с *реальными* зависимостями в изолированном окружении, а не с in-memory альтернативами (H2) или моками.
        *   **WireMock, MockServer:** Инструменты для мокирования внешних HTTP API.
        *   **Базы данных:** H2 Database (in-memory, для простых тестов), Testcontainers (для тестов с реальной БД).

---

## Принципы проектирования

### SOLID

Акроним для пяти основных принципов объектно-ориентированного проектирования, предложенных Робертом Мартином. Помогают создавать более понятные, гибкие, поддерживаемые и расширяемые системы.
*   **S – Single Responsibility Principle (Принцип единственной ответственности):**
    *   **Идея:** У класса должна быть только **одна причина для изменения**. Класс должен отвечать только за одну часть функциональности системы.
    *   **Цель:** Уменьшение связанности, повышение читаемости и простоты поддержки. Если класс делает слишком много, его сложно изменять и тестировать.
*   **O – Open/Closed Principle (Принцип открытости/закрытости):**
    *   **Идея:** Программные сущности (классы, модули, функции) должны быть **открыты для расширения, но закрыты для модификации**.
    *   **Цель:** Позволять добавлять новую функциональность, не изменяя существующий, уже протестированный код. Достигается через использование абстракций (интерфейсов, абстрактных классов), полиморфизма, шаблонов проектирования (Стратегия, Декоратор).
*   **L – Liskov Substitution Principle (Принцип подстановки Барбары Лисков):**
    *   **Идея:** Объекты в программе должны быть **заменяемы экземплярами их подтипов** без изменения правильности выполнения программы. Если `S` является подтипом `T`, то объекты типа `T` в программе можно заменять объектами типа `S` без каких-либо нежелательных последствий.
    *   **Цель:** Обеспечение корректной работы полиморфизма и наследования. Наследник не должен "ломать" контракт (ожидаемое поведение) базового класса. Он должен усиливать предусловия и ослаблять постусловия.
*   **I – Interface Segregation Principle (Принцип разделения интерфейсов):**
    *   **Идея:** Клиенты **не должны зависеть от методов интерфейса, которые они не используют**. Лучше иметь **много маленьких, специфичных интерфейсов**, чем один большой, "толстый" интерфейс общего назначения.
    *   **Цель:** Уменьшение связанности. Классы реализуют только те методы, которые им действительно нужны. Изменение интерфейса затрагивает меньше клиентов.
*   **D – Dependency Inversion Principle (Принцип инверсии зависимостей):**
    *   **Идея:**
        1.  Модули **верхних уровней** (например, бизнес-логика) не должны зависеть от модулей **нижних уровней** (например, конкретная реализация доступа к данным). Оба должны зависеть от **абстракций** (интерфейсов).
        2.  Абстракции не должны зависеть от **деталей** (конкретных реализаций). Детали должны зависеть от абстракций.
    *   **Цель:** Уменьшение связанности между компонентами системы. Повышение гибкости, тестируемости и возможности переиспользования. Часто реализуется с помощью **Dependency Injection (DI)**.

---

## Сетевые протоколы и Безопасность

### TLS (Transport Layer Security)

*   **Что такое:** Криптографический протокол, обеспечивающий **безопасную (конфиденциальную и целостную) передачу данных** между двумя приложениями по сети. Является преемником SSL (Secure Sockets Layer). Основа для HTTPS.
*   **Цели / Для чего используется:**
    *   **Шифрование (Конфиденциальность):** Защита передаваемых данных от прослушивания (перехвата) третьими лицами.
    *   **Аутентификация:** Проверка подлинности одной или обеих сторон взаимодействия (чаще всего сервера, иногда и клиента) с помощью цифровых сертификатов.
    *   **Целостность:** Гарантия того, что данные не были изменены (случайно или намеренно) во время передачи.
*   **Принципы работы (упрощенно, Handshake - Рукопожатие):** Процесс установления безопасного соединения:
    1.  **ClientHello:** Клиент отправляет серверу список поддерживаемых версий TLS, шифронаборов (Cipher Suites), методов сжатия и случайное число.
    2.  **ServerHello:** Сервер выбирает из предложенного клиентом наиболее безопасные параметры, с которыми он согласен работать, и отправляет их клиенту вместе со своим случайным числом.
    3.  **Certificate:** Сервер отправляет свой **цифровой сертификат** (X.509), содержащий его публичный ключ и информацию о владельце, подписанную доверенным центром сертификации (CA).
    4.  **(ServerKeyExchange):** (Если требуется) Сервер отправляет дополнительные данные для обмена ключами (например, параметры Диффи-Хеллмана).
    5.  **(CertificateRequest):** (Если требуется аутентификация клиента) Сервер запрашивает сертификат у клиента.
    6.  **ServerHelloDone:** Сервер сообщает, что закончил отправку данных.
    7.  **(Certificate):** (Если запрошен) Клиент отправляет свой сертификат.
    8.  **ClientKeyExchange:** Клиент генерирует **секретный ключ (pre-master secret)**, шифрует его **публичным ключом сервера** (из сертификата) и отправляет серверу. Либо используется протокол Диффи-Хеллмана для генерации общего секрета без его передачи по сети.
    9.  **(CertificateVerify):** (Если клиент отправлял сертификат) Клиент подписывает хеш предыдущих сообщений своим приватным ключом для подтверждения владения им.
    10. **ChangeCipherSpec:** Клиент сообщает, что переходит на шифрование согласованными ключами.
    11. **Finished:** Клиент отправляет зашифрованное сообщение с хешем всех предыдущих сообщений рукопожатия для проверки целостности.
    12. **ChangeCipherSpec:** Сервер сообщает, что переходит на шифрование.
    13. **Finished:** Сервер отправляет свое зашифрованное проверочное сообщение.
    *   После успешного рукопожатия обе стороны имеют общий **сеансовый симметричный ключ**, который используется для быстрого шифрования и дешифрования всех последующих данных сессии.

### HTTP (HyperText Transfer Protocol)

*   Протокол прикладного уровня для передачи гипермедиа-документов (например, HTML) и других данных в Интернете. Основа Веба. Работает по модели "клиент-сервер" (запрос-ответ).
*   **Основные методы (HTTP Verbs):** Указывают на желаемое действие над ресурсом.
    *   **GET:** Запрос представления ресурса. Безопасный (не должен изменять состояние сервера), идемпотентный.
    *   **POST:** Отправка данных на сервер для обработки (например, создание нового ресурса, отправка формы). Не безопасный, не идемпотентный.
    *   **PUT:** Замена (полное обновление) существующего ресурса данными из запроса, или создание ресурса, если он не существует по указанному URI. Идемпотентный.
    *   **DELETE:** Удаление указанного ресурса. Идемпотентный.
    *   **PATCH:** Частичное обновление ресурса. Не обязательно идемпотентный (зависит от реализации).
    *   **HEAD:** Аналогичен GET, но в ответе возвращаются только заголовки, без тела сообщения. Используется для проверки метаданных ресурса.
    *   **OPTIONS:** Запрос информации о доступных методах и опциях коммуникации для ресурса или сервера.
*   **Статус-коды ответа:** Числовой код, указывающий на результат обработки запроса сервером. Группируются по категориям:
    *   **1xx (Informational):** Запрос принят, обработка продолжается.
    *   **2xx (Success):** Запрос успешно принят, понят и обработан.
        *   `200 OK`: Успешный запрос (для GET, PUT, PATCH, DELETE).
        *   `201 Created`: Ресурс успешно создан (для POST, PUT).
        *   `204 No Content`: Успешный запрос, но в ответе нет тела (для DELETE).
    *   **3xx (Redirection):** Требуются дальнейшие действия для выполнения запроса (перенаправление).
        *   `301 Moved Permanently`: Ресурс навсегда перемещен на новый URI.
        *   `302 Found` / `307 Temporary Redirect`: Временное перенаправление.
        *   `304 Not Modified`: Ресурс не изменился с момента последнего запроса (используется с кешированием).
    *   **4xx (Client Error):** Ошибка на стороне клиента (неверный запрос, нет прав).
        *   `400 Bad Request`: Неверный синтаксис запроса.
        *   `401 Unauthorized`: Требуется аутентификация.
        *   `403 Forbidden`: Аутентификация прошла, но доступ запрещен (нет прав).
        *   `404 Not Found`: Запрошенный ресурс не найден.
        *   `405 Method Not Allowed`: Используемый HTTP метод не поддерживается для данного ресурса.
        *   `409 Conflict`: Конфликт запроса с текущим состоянием ресурса.
    *   **5xx (Server Error):** Ошибка на стороне сервера при обработке корректного запроса.
        *   `500 Internal Server Error`: Общая ошибка сервера.
        *   `502 Bad Gateway`: Сервер, выступающий как шлюз или прокси, получил недействительный ответ от вышестоящего сервера.
        *   `503 Service Unavailable`: Сервер временно недоступен (перегружен, на обслуживании).
        *   `504 Gateway Timeout`: Сервер-шлюз не дождался ответа от вышестоящего сервера.
*   **Идемпотентность (Idempotency):** Свойство операции (HTTP метода), при котором **повторное выполнение** этой операции с теми же параметрами приводит к **тому же результату (состоянию на сервере)**, что и однократное выполнение.
    *   **Идемпотентные методы:** GET, HEAD, OPTIONS, PUT, DELETE.
    *   **Неидемпотентные методы:** POST (обычно создает новый ресурс при каждом вызове), PATCH (может быть, может не быть).
    *   Важно для построения надежных API, особенно при возможных сетевых сбоях и повторных отправках запросов.

### CORS (Cross-Origin Resource Sharing)

*   **Что такое:** Механизм безопасности браузера, который **ограничивает** возможность веб-страницы, загруженной с **одного домена (origin)**, делать запросы (обычно AJAX/Fetch) к ресурсам, расположенным на **другом домене**. "Origin" определяется схемой (http/https), хостом (доменом) и портом.
*   **Зачем нужно:** Предотвращает атаки типа **CSRF (Cross-Site Request Forgery)** в некоторых сценариях и защищает пользовательские данные от несанкционированного доступа со сторонних сайтов.
*   **Как работает:**
    1.  Когда браузер пытается выполнить "cross-origin" запрос (кроме "простых" запросов типа GET/HEAD/POST с простыми заголовками), он сначала отправляет **предварительный запрос (preflight request)** с использованием HTTP метода **`OPTIONS`** на целевой ресурс. Этот запрос содержит заголовки `Origin` (откуда идет запрос), `Access-Control-Request-Method` (какой метод будет в основном запросе), `Access-Control-Request-Headers` (какие заголовки будут).
    2.  Сервер **должен** ответить на `OPTIONS` запрос, указав в **заголовках ответа**, разрешает ли он такой запрос с данного `Origin`:
        *   `Access-Control-Allow-Origin`: Разрешенный домен (или `*` - любой, **не рекомендуется для запросов с credentials**).
        *   `Access-Control-Allow-Methods`: Разрешенные HTTP методы.
        *   `Access-Control-Allow-Headers`: Разрешенные заголовки.
        *   `Access-Control-Allow-Credentials`: Разрешает ли сервер отправку cookies и данных аутентификации (`true`/`false`).
        *   `Access-Control-Max-Age`: На какое время браузер может закешировать результат preflight запроса.
    3.  Если ответ на `OPTIONS` разрешает запрос, браузер отправляет **основной** HTTP-запрос (GET, POST и т.д.). Сервер в ответе на основной запрос также должен включить заголовок `Access-Control-Allow-Origin`.
*   **Настройка на бэкенде (Spring):**
    *   Глобально через `WebMvcConfigurer` bean и метод `addCorsMappings`.
    *   На уровне контроллера или метода с помощью аннотации `@CrossOrigin`.

### Веб-безопасность

Помимо SQL Injection и CORS, важно знать о других распространенных уязвимостях:
*   **XSS (Cross-Site Scripting):** Атака, при которой злоумышленник внедряет вредоносный скрипт (обычно JavaScript) на веб-страницу, который затем выполняется в браузере другого пользователя. Может использоваться для кражи сессий (cookies), редиректа, изменения содержимого страницы.
    *   **Защита:** Экранирование (escaping) всего пользовательского вывода на HTML-страницах, Content Security Policy (CSP) заголовки, использование фреймворков с встроенной защитой.
*   **CSRF (Cross-Site Request Forgery - Межсайтовая подделка запроса):** Атака, при которой злоумышленник заставляет браузер аутентифицированного пользователя выполнить нежелательное действие на сайте, где пользователь аутентифицирован (например, перевести деньги, изменить пароль), путем перехода по вредоносной ссылке или загрузки вредоносного контента.
    *   **Защита:** Использование **CSRF-токенов** (уникальный секретный токен для каждой сессии пользователя, который должен присутствовать в запросах, изменяющих состояние), проверка заголовка `Origin` или `Referer`, SameSite атрибут для cookies. Spring Security имеет встроенную защиту от CSRF (обычно включена по умолчанию).

### Rate Limiter

*   **Что такое:** Механизм для **ограничения количества запросов**, которые клиент (или IP-адрес, пользователь) может сделать к API или сервису за определенный промежуток времени (например, не более 100 запросов в минуту).
*   **Зачем нужно:**
    *   **Защита от перегрузки:** Предотвращает исчерпание ресурсов сервера из-за слишком большого числа запросов.
    *   **Защита от DDoS-атак (частично):** Помогает смягчить атаки типа "отказ в обслуживании".
    *   **Обеспечение честного использования (Fair Usage):** Гарантирует, что один пользователь не монополизирует ресурсы API.
    *   **Безопасность:** Может замедлить атаки перебора паролей (brute-force).
    *   **Монетизация API:** Ограничение использования в бесплатных тарифах.
*   **Алгоритмы:** Token Bucket, Leaky Bucket, Fixed Window Counter, Sliding Window Log, Sliding Window Counter.
*   **Реализации:** Часто встраивается в API Gateway (Kong, Nginx) или реализуется с помощью библиотек (Resilience4j, Guava RateLimiter) на уровне приложения.

---

## Алгоритмы и Структуры данных

### Временная сложность (Time Complexity)

*   **Что такое:** Оценка того, как **время выполнения** алгоритма растет с **увеличением размера входных данных (n)**. Используется нотация **"O-большое" (Big O)**, которая описывает **асимптотическое поведение** в **худшем случае** (или иногда в среднем).
*   **Основные классы сложности (от лучших к худшим):**
    *   `O(1)`: Константное время (не зависит от n). Пример: доступ к элементу массива по индексу, вставка/удаление в `HashMap` (в среднем).
    *   `O(log n)`: Логарифмическое время. Пример: бинарный поиск в отсортированном массиве, операции в сбалансированных деревьях (`TreeMap`, `TreeSet`).
    *   `O(n)`: Линейное время. Пример: поиск в несортированном массиве/списке, итерация по коллекции.
    *   `O(n log n)`: Линейно-логарифмическое время. Пример: эффективные сортировки (слиянием, быстрая - в среднем, пирамидальная).
    *   `O(n^2)`: Квадратичное время. Пример: неэффективные сортировки (пузырьком, вставками, выбором), вложенные циклы по одной коллекции.
    *   `O(2^n)`: Экспоненциальное время. Пример: переборные задачи (например, нахождение всех подмножеств).
    *   `O(n!)`: Факториальное время. Пример: решение задачи коммивояжера перебором.
*   **Примеры для конкретных алгоритмов/структур:**
    *   **Поиск в глубину (DFS) / Поиск в ширину (BFS) на графе:** `O(V + E)` (V - количество вершин, E - количество рёбер).
    *   **Самая быстрая сортировка (в среднем):** `O(n log n)` (QuickSort, MergeSort, HeapSort). Худший случай QuickSort - `O(n^2)`.
    *   **Вставка в HashMap:** Средняя - `O(1)`, Худшая - `O(n)` (при плохом хэшировании и коллизиях).
    *   **Поиск по ключу в HashMap:** Средняя - `O(1)`, Худшая - `O(n)`.
    *   **Вставка в LinkedList:**
        *   В начало/конец (если есть ссылка на хвост): `O(1)`.
        *   По индексу / По значению (поиск): `O(n)`.
        *   В середину (если есть итератор/указатель на предыдущий узел): `O(1)`.
    *   **Вставка/Поиск в ArrayList:**
        *   Доступ по индексу: `O(1)`.
        *   Вставка/Удаление в конец (если не требуется resize): `O(1)` (амортизированное).
        *   Вставка/Удаление в начало/середину: `O(n)` (сдвиг элементов).
        *   Поиск по значению: `O(n)`.
    *   **Вставка/Поиск/Удаление в сбалансированном бинарном дереве поиска (TreeMap, TreeSet):** `O(log n)`.


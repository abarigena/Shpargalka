# Вопросы для собеседований по Java

## Содержание
1. [Вопросы для собеседования по Java - Часть 1](#вопросы-для-собеседования-по-java---часть-1)
2. [Вопросы для собеседований по Java - Часть 2](#вопросы-для-собеседований-по-java-разработке---часть-2)

# Вопросы для собеседования по Java - Часть 1

## Содержание
1. [ООП концепции](#ооп-концепции)
    - [Абстрактные классы](#абстрактные-классы)
    - [Интерфейсы](#интерфейсы)
    - [Сравнение абстрактных классов и интерфейсов](#сравнение-абстрактных-классов-и-интерфейсов)
2. [Обобщения (Generics)](#обобщения-generics)
    - [Принцип PECS](#принцип-pecs)
    - [Стирание типов](#стирание-типов)
3. [Исключения](#исключения)
    - [Типы исключений](#типы-исключений)
    - [Иерархия исключений](#иерархия-исключений)
    - [Обработка исключений](#обработка-исключений)
    - [Try-with-resources](#try-with-resources)
4. [Stream API](#stream-api)
    - [Типы операций](#типы-операций)
    - [Map и FlatMap](#map-и-flatmap)
    - [Параллельный Stream](#параллельный-stream)
5. [Ссылки на методы](#ссылки-на-методы)
6. [Рефлексия](#рефлексия)
7. [Сборщик мусора](#сборщик-мусора)
    - [Принцип работы](#принцип-работы)
    - [Алгоритмы сборки мусора](#алгоритмы-сборки-мусора)
    - [Типы сборщиков мусора](#типы-сборщиков-мусора)
8. [Коллекции](#коллекции)
    - [Иерархия коллекций](#иерархия-коллекций)
    - [Map](#map)
    - [Принцип работы HashMap](#принцип-работы-hashmap)

## ООП концепции

### Абстрактные классы

**Что такое абстрактный класс?**

Абстрактный класс — это класс, который может содержать как абстрактные методы (без реализации), которые должны быть реализованы в подклассах, так и методы с реализацией. Его нельзя создать напрямую, он служит для расширения другими классами. Абстрактный класс может содержать конструкторы и методы с различными модификаторами доступа.

### Интерфейсы

**Что такое интерфейс?**

Интерфейс — это контракт, который определяет набор методов, которые класс должен реализовать. Все методы в интерфейсе по умолчанию абстрактные, хотя могут содержать дефолтную реализацию. Классы могут имплементировать несколько интерфейсов.

**Дефолтная реализация?**

Методы с реализацией, которую класс не обязан переопределять. Класс может использовать реализацию из интерфейса или переопределить её.

### Сравнение абстрактных классов и интерфейсов

**Разница между интерфейсом и абстрактным классом?**

1. Интерфейс не может содержать полей с состоянием (могут быть только константы).
2. Класс может наследовать только 1 абстрактный класс, но может имплементировать несколько интерфейсов.
3. В интерфейсе все методы по умолчанию абстрактные, в абстрактном классе могут быть как абстрактные методы, так и обычные.
4. Интерфейсы не могут содержать конструкторы.

## Обобщения (Generics)

**Что такое generic типы?**

Обобщенные типы позволяют создавать классы, интерфейсы и методы, которые работают с разными типами данных.

Основные преимущества:
- **Типобезопасность** — Ошибки с приведением типов обнаруживаются на этапе компиляции.
- **Повторное использование кода** — можно использовать для разных типов данных.
- **Исключается необходимость явного приведения типов**.

### Принцип PECS

**Что такое принцип PECS?**

Принцип "Producer Extends, Consumer Super" (поставщик и потребитель данных) помогает использовать wildcard (подстановочные знаки ? в обобщениях) в параметрах методов.

- Если коллекция используется как поставщик (Producer), используйте `<? extends T>` — позволяет читать данные, но не добавлять новые:
  ```java
  public void process(List<? extends Number> list) {
      Number n = list.get(0); // Можно получить элемент
      // list.add(new Integer(1)); // Ошибка компиляции
  }
  ```

- Если коллекция используется как потребитель (Consumer), используйте `<? super T>` — позволяет добавлять элементы, но не получать их с конкретным типом:
  ```java
  public void addToList(List<? super Integer> list) {
      list.add(10); // Можно добавить Integer
      // Integer i = list.get(0); // Ошибка компиляции, тип элемента неизвестен
  }
  ```

### Стирание типов

**Можем ли мы узнать тип T в рантайме?**

Нет, невозможно узнать тип T в рантайме из-за стирания типов (type erasure). Информация о типах обобщения удаляется и заменяется их ограничениями (Object или конкретный класс) во время компиляции.

## Исключения

### Типы исключений

**Типы исключений Checked и Unchecked?**

**Checked (проверяемые):**
- Для ошибок, которые можно предсказать и которые нужно обработать.
- Должны быть либо обработаны с помощью try-catch, либо объявлены в методе через throws.
- Пример: IOException, SQLException.

**Unchecked (Непроверяемые):**
- Для ошибок, которые возникают из-за ошибок программирования и могут быть исправлены в самом коде.
- Пример: NullPointerException, ArrayIndexOutOfBoundsException.

### Иерархия исключений

**Какой верхнеуровневый класс есть у всех исключений?**

Верхнеуровневый класс — Throwable, который делится на два основных подкласса:
- **Exception** — для исключений, которые можно обработать в программе.
- **Error** — для серьезных проблем, которые не подлежат обработке (например, ошибки, связанные с JVM).

Все исключения наследуются от Throwable.

### Обработка исключений

**Хорошее ли правило обработать Throwable сразу?**

Не лучшая практика. Лучше обрабатывать конкретные исключения (IOException, NullPointerException).

Почему не лучшая практика:
- Throwable включает Error, их не рекомендуется перехватывать, так как они могут скрыть серьёзные проблемы.
- При перехвате общего типа можно потерять информацию о конкретной причине исключения.

Когда можно использовать:
- Для логирования всех возможных исключений.

Лучше перехватывать только те исключения, которые ожидаете.

**Можно ли использовать try-finally без catch?**

Можно. Это полезно для очистки ресурсов (например, закрытие потоков), даже если исключения не обрабатываются. Саму ошибку можно либо обработать в другом месте, либо прокинуть дальше.

### Try-with-resources

**Блок try-with-resources?**

Можно использовать для автоматического закрытия ресурсов, реализующих интерфейс AutoCloseable. Ресурс закрывается, когда выполнение выходит из блока try.

```java
try (FileInputStream input = new FileInputStream("file.txt")) {
    // работа с ресурсом
} // ресурс закрывается автоматически
```

## Stream API

### Типы операций

**Stream API два типа операций какие?**

**Промежуточные операции (Intermediate operations):**
- Трансформируют или фильтруют поток данных, возвращая новый поток.
- Они **ленивы** — не выполняются до тех пор, пока не будет вызвана заключительная операция.
- Примеры: filter(), map(), flatMap(), sorted(), distinct().

**Заключительные операции (Terminal operations):**
- Запускают обработку данных, описанных в потоке.
- Приводят к завершению работы потока, выполняя окончательное действие.
- После операции поток не может быть использован.
- Примеры: collect(), forEach(), reduce(), count(), findFirst().

**Основная разница:** промежуточные операции создают новые потоки и не выполняются до вызова терминальной операции, которая завершает поток и запускает выполнение всех промежуточных операций.

**Получится ли отсортировать или использовать любую промежуточную операцию после forEach() или любой другой завершающей операции?**

Не получится, так как поток будет закрыт (завершён) после выполнения терминальной операции.

### Map и FlatMap

**Метод map в Stream API**

Метод map() используется для преобразования (маппинга) каждого элемента потока в другой элемент. Применяет переданную функцию к каждому элементу.

Пример:
```java
List<String> names = Arrays.asList("John", "Jane", "Alex");
List<Integer> nameLengths = names.stream()
    .map(String::length) // Преобразуем строку в её длину
    .collect(Collectors.toList());
System.out.println(nameLengths); // Выведет: [4, 4, 4]
```

- Промежуточная операция.
- Применяет функцию к каждому элементу.
- Не изменяет поток, а возвращает новый.

**Метод flatMap в Stream API**

Преобразует каждый элемент потока в другой поток (или коллекцию) и затем объединяет все потоки в один. Используется для работы с вложенными структурами.

Пример:
```java
List<List<Integer>> listOfLists = List.of(
    List.of(1, 2, 3),
    List.of(4, 5),
    List.of(6, 7, 8)
);
List<Integer> flattened = listOfLists.stream()
    .flatMap(List::stream) // Преобразует каждый List в поток и объединяет их в один
    .collect(Collectors.toList());
System.out.println(flattened); // Вывод: [1, 2, 3, 4, 5, 6, 7, 8]
```

**Сохраняется ли структура при использовании map или flatMap?**

- При использовании map() структура сохраняется, так как создается новый поток с такими же элементами, но преобразованными.
- При использовании flatMap() структура может измениться, так как результат может быть "спрямленной" коллекцией или потоком.

### Параллельный Stream

**Параллельный Stream?**

Позволяет использовать многозадачность для обработки элементов потока.
- Разделяет поток на несколько частей, которые обрабатываются параллельно.
- Достаточно вызвать метод parallel().

Как работает?
- Делит поток на несколько подзадач, которые выполняются параллельно, используя доступные ядра процессора.
- Java сама распределяет элементы между несколькими потоками и синхронизирует данные.

Важные моменты:
- Не всегда ускоряет обработку, особенно если операции не требуют много вычислений или данных мало.
- При параллельном изменении данных нужно либо учитывать возможные проблемы синхронизации, либо использовать потокобезопасные структуры.
- Операции, такие как forEach() или sorted(), сохраняют порядок в параллельном потоке, но могут быть менее эффективными.

## Ссылки на методы

**Что такое ссылка на метод?**

Короткая форма записи, когда нужно передать ссылку на уже существующий метод вместо полного лямбда-выражения. Используется оператор `::`.

Пример:
```java
public class Example {
    public void printMessage(String message) {
        System.out.println(message);
    }

    public static void main(String[] args) {
        Example example = new Example();
        List<String> messages = Arrays.asList("Hello", "World", "Java");
        
        // Используем ссылку на метод экземпляра
        messages.forEach(example::printMessage); // Эквивалентно messages.forEach(m -> example.printMessage(m));
    }
}
```

Ссылки на метод можно использовать в коллекциях, потоках и других функциональных интерфейсах.

## Рефлексия

**Что такое Рефлексия?**

Механизм, который позволяет исследовать или изменять структуры классов, методов и полей во время выполнения программы.

Основные возможности:
- Получение информации о классе: имя, модификаторы, методы, поля.
- Динамическое создание объектов класса, даже если тип неизвестен во время компиляции.
- Вызов методов и изменение полей, даже если они private.

Пример:
```java
public class Example {
    private String name;
    
    public Example(String name) {
        this.name = name;
    }
    
    public void printName() {
        System.out.println(name);
    }
    
    public static void main(String[] args) throws Exception {
        // Получаем класс через рефлексию
        Class<?> clazz = Example.class;
        
        // Получаем имя класса
        System.out.println("Class Name: " + clazz.getName());
        
        // Получаем методы класса
        for (Method method : clazz.getDeclaredMethods()) {
            System.out.println("Method: " + method.getName());
        }
    }
}
```

## Сборщик мусора

**Сборщик мусора**

Система управления памятью, которая автоматически освобождает неиспользуемые объекты, на которые больше не ссылаются переменные или другие объекты.

### Принцип работы

**Как работает сборщик мусора**

- **Отслеживание ссылок**: если объект не имеет ссылок, он может быть удален.
- **Определение достижимости**: если на объект нельзя попасть через цепочку ссылок, начиная с корней (статические переменные, локальные переменные на стеке и т.д.), он может быть удален.
- **Этапы работы**:
    - Молодое поколение: объекты создаются здесь; если переживают несколько сборок мусора, переходят в старое поколение.
    - Старое поколение: содержит долгоживущие объекты, пережившие несколько сборок мусора.
    - Сборка мусора может вызывать паузы в работе программы (Stop-the-World), во время которых выполнение программы приостанавливается.

### Алгоритмы сборки мусора

- **Алгоритм "Mark-and-Sweep"**:
    - **Mark**: Все достижимые объекты маркируются как живые.
    - **Sweep**: Все объекты, не маркированные как живые, удаляются.

- **Алгоритм "Stop-the-World"**: Фаза, когда выполнение программы приостанавливается для выполнения сборки мусора.

- **Алгоритм "Generational Garbage Collection"**: Разделяет объекты на молодое и старое поколения для оптимизации работы.

### Типы сборщиков мусора

**Типы сборщиков мусора в Java**:

- **Serial Garbage Collector**: Использует один поток для работы, подходит для небольших приложений.
- **Parallel Garbage Collector**: Использует несколько потоков для ускорения процесса, подходит для многозадачных серверных приложений.
- **CMS (Concurrent Mark-Sweep)**: Сборщик, который выполняет большую часть работы параллельно с приложением, минимизируя время пауз.
- **G1 Garbage Collector**: Более новый сборщик, который разделяет память на регионы и эффективнее управляет временем пауз и памятью.

## Коллекции

### Иерархия коллекций

**Collection (Основной интерфейс)**
- Определяет основные операции для работы с коллекциями.
- **Методы**: add(), remove(), contains(), size(), clear() и другие.

**List (Интерфейс для списков)**
- Расширяет Collection для работы с упорядоченными коллекциями, где элементы доступны по индексам.
- **Методы**: get(), set(), add(), remove(), indexOf(), subList() и другие.
- **Основные реализации**: ArrayList, LinkedList, Vector, Stack.

**Set (Интерфейс для множеств)**
- Расширяет Collection для работы с коллекциями, где элементы уникальны.
- **Методы**: add(), remove(), contains() и другие.
- **Основные реализации**: HashSet, LinkedHashSet, TreeSet.

**Queue (Интерфейс для очередей)**
- Расширяет Collection для реализации структуры данных "очередь" (FIFO).
- **Методы**: offer(), poll(), peek() и другие.
- **Основные реализации**: PriorityQueue, LinkedList, ArrayDeque.

**Deque (Интерфейс для двусторонних очередей)**
- Расширяет Queue для работы с двусторонними очередями.
- **Методы**: addFirst(), addLast(), removeFirst(), removeLast() и другие.
- **Основные реализации**: ArrayDeque, LinkedList.

### Map

**Map (Интерфейс для ассоциативных массивов)**
- Интерфейс для коллекций, хранящих пары "ключ-значение". Не наследует от Collection.
- **Методы**: put(), get(), containsKey(), containsValue(), remove() и другие.
- **Основные реализации**: HashMap, LinkedHashMap, TreeMap, Hashtable, ConcurrentHashMap.

**Map и Collection — это интерфейсы?**

Да, Map и Collection — это интерфейсы, а не классы:
- **Collection** — корневой интерфейс для всех коллекций в Java (кроме Map).
- **Map** — интерфейс для коллекций пар "ключ-значение", не наследуется от Collection.

### Принцип работы HashMap

**Как работает HashMap?**

HashMap хранит данные в виде пар "ключ-значение", где ключ используется для быстрого поиска соответствующего значения:

1. При добавлении элемента (пары "ключ-значение") хеш-функция вычисляет хеш-значение для ключа.
2. Это хеш-значение используется для вычисления индекса в массиве (бакете), где будет храниться пара.
3. В случае коллизий (когда разные ключи имеют одинаковое хеш-значение) HashMap использует методы для их разрешения:
    - В Java 8+ при большом количестве коллизий в одном бакете вместо связного списка используется дерево (красно-черное).
4. HashMap использует массив бакетов, и каждый бакет содержит связанные списки или деревья для хранения элементов с одинаковыми хешами.
5. При добавлении, удалении или поиске хеш-функция используется для быстрого нахождения нужного бакета.
6. Если количество элементов превышает определённый порог (load factor), размер HashMap автоматически увеличивается через перераспределение всех элементов.

# Вопросы для собеседований по Java-разработке - Часть 2

## Содержание
1. [Многопоточность](#многопоточность)
    - [Основные компоненты многопоточности в Java](#основные-компоненты-многопоточности-в-java)
    - [Executor Framework](#executor-framework)
    - [java.util.concurrent](#javautilconcurrent)
    - [ForkJoinPool](#forkjoinpool)
    - [Процессы и потоки](#процессы-и-потоки)
    - [Состояния потоков](#состояния-потоков)
    - [Демон-потоки и пользовательские потоки](#демон-потоки-и-пользовательские-потоки)

2. [Spring Framework](#spring-framework)
    - [Spring и Spring Boot](#spring-и-spring-boot)
    - [Внедрение зависимостей](#внедрение-зависимостей)
    - [Жизненный цикл бина](#жизненный-цикл-бина)
    - [Scope бинов](#scope-бинов)
    - [Транзакции](#транзакции)
    - [AOP](#aop-аспектно-ориентированное-программирование)
    - [Прокси-объекты](#прокси-объекты)
    - [Планировщик задач](#планировщик-задач)

3. [Базы данных](#базы-данных)
    - [Уровни изоляции транзакций](#уровни-изоляции-транзакций)
    - [ACID](#acid)
    - [Liquibase](#liquibase)

4. [Тестирование](#тестирование)
    - [Модульное тестирование](#модульное-тестирование)
    - [Интеграционное тестирование](#интеграционное-тестирование)

5. [Сборка и управление проектами](#сборка-и-управление-проектами)
    - [Maven](#maven)
    - [Scope зависимостей](#scope-зависимостей)
    - [Git](#git)

## Многопоточность

Многопоточность - это возможность выполнять несколько операций одновременно с использованием нескольких потоков.

### Основные компоненты многопоточности в Java

**Thread (Поток)**: Класс Thread предоставляет способы создания, запуска и управления потоками.
- `run()` - метод, который переопределяется для выполнения кода потока.
- `start()` - запускает новый поток и вызывает метод run().
- `sleep()` - заставляет поток "спать" на определённое время.
- `join()` - ожидание завершения другого потока.

**Runnable (Интерфейс)**: интерфейс, который позволяет создавать потоки более гибким способом.
- Содержит единственный метод `run()`, который описывает код, выполняемый в потоке.
- Объекты Runnable передаются в конструктор класса Thread или могут быть использованы с пулом потоков для многозадачности.

### Executor Framework

Это набор интерфейсов и классов, предназначенных для управления потоками в Java.

Основные компоненты:

1. **Executor** - интерфейс с методом `execute(Runnable command)`, который выполняет задачу в отдельном потоке.

2. **ExecutorService** - расширяет Executor и добавляет методы для управления жизненным циклом задач:
    - **submit()**: Принимает задачу в виде Runnable или Callable и возвращает объект Future.
   ```java
   ExecutorService executor = Executors.newFixedThreadPool(2);
   Future<?> future = executor.submit(() -> {
       // код задачи
   });
   ```

    - **shutdown()**: Инициирует процесс завершения работы пула потоков. После вызова новые задачи не принимаются, но уже запущенные продолжают выполняться.
   ```java
   executor.shutdown();
   ```

    - **invokeAll()**: Принимает коллекцию задач (Callable) и выполняет их параллельно. Блокирует выполнение до завершения всех задач.
   ```java
   List<Callable<Integer>> tasks = Arrays.asList(() -> 1, () -> 2);
   List<Future<Integer>> results = executor.invokeAll(tasks);
   ```

3. **ThreadPoolExecutor** - конкретная реализация ExecutorService, которая управляет пулом потоков.

### java.util.concurrent

Пакет `java.util.concurrent` предоставляет набор классов и интерфейсов для удобной работы с многозадачностью и синхронизацией потоков.

Основные элементы:

1. **Синхронизация:**
    - **ReentrantLock** - более гибкий аналог synchronized, позволяющий контролировать захват блокировок, поддерживает время ожидания и прерывания.
    - **ReadWriteLock** - позволяет использовать отдельные блокировки для чтения и записи, что увеличивает производительность при многократных чтениях.

2. **Пулы потоков:**
    - **ExecutorService** - интерфейс для управления пулом потоков.
    - **ThreadPoolExecutor** - реализация ExecutorService для работы с пулом потоков.
    - **ScheduledExecutorService** - интерфейс для планирования задач с задержкой или с фиксированным интервалом.

3. **Коллекции:**
    - **BlockingQueue** - коллекция с блокировкой для безопасной работы с потоками (ArrayBlockingQueue, LinkedBlockingQueue).
    - **CopyOnWriteArrayList** и **CopyOnWriteArraySet** - коллекции, безопасные для изменения из нескольких потоков.

4. **Синхронизация между потоками:**
    - **CountDownLatch** - позволяет одному или нескольким потокам ожидать завершения других потоков.
    - **CyclicBarrier** - синхронизирует группу потоков, заставляя их ожидать друг друга на определённом барьере.
    - **Semaphore** - ограничивает количество потоков, которые могут одновременно получить доступ к ресурсу.
    - **Exchanger** - позволяет двум потокам обмениваться данными.

5. **Атомарные операции:**
    - **AtomicInteger**, **AtomicLong**, **AtomicReference** - классы для атомарных операций с примитивными типами и объектами.

### ForkJoinPool

**ForkJoinPool** - это специализированный пул потоков, предназначенный для задач, которые могут быть рекурсивно разделены на подзадачи (алгоритм "разделяй и властвуй"). Оптимизирован для параллельных вычислений.

- **Разделение задач (Forking)**: Задачи могут быть разделены на подзадачи с помощью метода `fork()`.
- **Объединение результатов (Joining)**: Результаты подзадач собираются с помощью метода `join()`.

### Процессы и потоки

**Процесс** - это экземпляр программы, который выполняется в операционной системе.
**Поток** - наименьшая единица выполнения в рамках процесса.

Основные отличия:
- **Создание**: Процесс создаётся с помощью системных вызовов (fork(), CreateProcess()), поток - через класс Thread или интерфейс Runnable.
- **Изоляция**: Процесс изолирован от других процессов, потоки разделяют пространство процесса и могут влиять друг на друга.
- **Коммуникация**: Потоки могут обмениваться данными напрямую, процессы требуют специальных механизмов межпроцессного взаимодействия.
- **Управление**: Процесс управляется операционной системой, потоки - планировщиком потоков.

### Состояния потоков

1. **New (Новый)**: Начальное состояние после создания потока (`new Thread`).
2. **Runnable (Рабочий)**: Поток готов к выполнению после вызова `start()`.
3. **Blocked (Заблокированный)**: Поток ожидает доступа к ресурсу, заблокированному другим потоком (например, при входе в синхронизированный блок).
4. **Waiting (Ожидание)**: Поток ожидает, что другой поток выполнит определённое действие (например, при вызове `wait()` или `join()`).
5. **Timed Waiting (Ожидание с таймером)**: Поток ожидает определённое время (например, при вызове `sleep(1000)`).
6. **Terminated (Завершённый)**: Поток завершил свою работу.

### Демон-потоки и пользовательские потоки

**Демон-поток (daemon thread)**:
- Работает в фоновом режиме и не мешает завершению программы.
- Автоматически завершается, когда все пользовательские потоки завершены.
- Используется для задач обслуживания (например, сборщик мусора).
- Устанавливается с помощью метода `setDaemon(true)` до запуска потока.

**Пользовательский поток (user thread)**:
- Стандартный поток, JVM ожидает их завершения перед закрытием.
- По умолчанию все создаваемые потоки являются пользовательскими.

## Spring Framework

### Spring и Spring Boot

**Spring Framework**:
- Требует более значительных усилий в настройке и конфигурации.
- Чаще всего использует XML-конфигурацию или аннотации.
- Предоставляет гибкую настройку для различных сценариев.

**Spring Boot**:
- Упрощает разработку приложений Spring с минимальной конфигурацией.
- Предоставляет:
    1. **Автоконфигурацию** - автоматически настраивает компоненты Spring в зависимости от подключенных библиотек.
    2. **Встроенный сервер** (Tomcat, Jetty) - позволяет запускать приложения без внешнего сервера.
    3. **Минимум конфигураций** - использует разумные настройки по умолчанию.
    4. **Поддержка готовых стартеров** - предустановленные зависимости для популярных технологий.

**Отличия в настройке**:
- Spring настраивается с помощью XML или аннотаций.
- Spring Boot использует автоконфигурацию и файлы `application.properties`/`application.yml`.

### Внедрение зависимостей

Способы внедрения зависимостей в Spring:

1. **Через конструктор** (рекомендуемый способ):
   ```java
   @Autowired
   public MyService(MyRepository repository) {
       this.repository = repository;
   }
   ```
    - Делает зависимости обязательными.
    - Обеспечивает неизменяемость.
    - Улучшает тестируемость.

2. **Через сеттер**:
   ```java
   @Autowired
   public void setRepository(MyRepository repository) {
       this.repository = repository;
   }
   ```
    - Полезно для опциональных зависимостей.
    - Может решать проблемы циклических зависимостей.

3. **Через поля**:
   ```java
   @Autowired
   private MyRepository repository;
   ```
    - Наиболее лаконичный способ.
    - Не делает зависимости обязательными.
    - Сложнее тестировать.

4. **Аннотация @Value** для примитивов и строк:
   ```java
   @Value("${property.name}")
   private String propertyValue;
   ```

### Жизненный цикл бина

1. **Создание бина**
    - Spring создает экземпляры классов с аннотациями @Component, @Service, @Repository и т.д.

2. **Внедрение зависимостей**
    - Spring внедряет зависимости через конструктор, сеттеры или поля.

3. **Выполнение методов инициализации**
    - `@PostConstruct` или метод, указанный в init-method.

4. **Использование бина**
    - Бин доступен для использования в приложении.

5. **Выполнение методов разрушения**
    - `@PreDestroy` или метод, указанный в destroy-method.

6. **Удаление из контекста**
    - Bean удаляется из контекста Spring.

### Scope бинов

**Singleton** (по умолчанию):
- Один экземпляр на приложение.
- Бин создается при старте приложения.
- Общий для всех.

**Prototype**:
- Новый экземпляр при каждом запросе.
- Не сохраняется в контейнере после использования.
- Каждый экземпляр независим от других.

Другие scope:
- **request** - один экземпляр на HTTP-запрос.
- **session** - один экземпляр на HTTP-сессию.
- **application** - один экземпляр на ServletContext.
- **websocket** - один экземпляр на WebSocket.

### Транзакции

**Аннотация @Transactional**:
- Гарантирует, что все операции внутри метода или класса будут выполнены в рамках одной транзакции.
- При возникновении исключений изменения откатываются.

**Параметры**:
- `rollbackFor` - указывает, для каких исключений делать откат.
- `readOnly` - указывает, что метод только читает данные.
- `propagation` - определяет как транзакции взаимодействуют между собой.
- `isolation` - устанавливает уровень изоляции.

**Вложенные транзакции**:
Если сервис с аннотацией @Transactional вызывает другой сервис с @Transactional, по умолчанию используется одна транзакция (поведение REQUIRED). Это можно изменить с помощью параметра `propagation`.

**На основе чего работают транзакции**:
- ACID-принципы.
- PlatformTransactionManager для управления транзакциями.
- Прокси-объекты, которые перехватывают вызовы методов для начала, коммита и отката транзакций.

### AOP (Аспектно-ориентированное программирование)

AOP - подход, позволяющий отделить сквозную логику (логирование, транзакции, безопасность) от основной бизнес-логики приложения.

Основные понятия:
- **Аспект (Aspect)** - модуль, содержащий сквозную логику.
- **Совет (Advice)** - действие, выполняемое в определенный момент (before, after, around).
- **Точка соединения (Join Point)** - момент в выполнении программы (вызов метода).
- **Срез (Pointcut)** - выражение, определяющее, к каким методам применяется аспект.

### Прокси-объекты

Прокси-объекты - это заместители других объектов, которые обеспечивают дополнительную функциональность.

Применение в Spring:
- **AOP** - прокси добавляет сквозную логику к основному объекту.
- **Ленивая инициализация** - прокси создается сразу, настоящий объект - при первом вызове.
- **Безопасность и транзакции** - прокси контролирует доступ и управляет транзакциями.

Spring создает два типа прокси:
- **JDK Dynamic Proxies** - для объектов, реализующих интерфейсы.
- **CGLIB Proxies** - для классов без интерфейсов.

### Планировщик задач

Spring предоставляет планировщик задач с помощью аннотации `@Scheduled`, которая позволяет выполнять методы по расписанию.

```java
@Scheduled(fixedRate = 5000)
public void executeTask() {
    // Метод будет вызываться каждые 5 секунд
}

@Scheduled(cron = "0 0 12 * * ?")
public void executeTaskAtNoon() {
    // Метод будет вызываться в 12:00 каждый день
}
```

## Базы данных

### Уровни изоляции транзакций

Уровни изоляции определяют, как изменения в одной транзакции видны другим транзакциям:

1. **READ UNCOMMITTED (Чтение незавершенных данных)**
    - Транзакции могут читать незафиксированные данные.
    - Проблема: **грязное чтение** (dirty read).

2. **READ COMMITTED (Чтение подтвержденных данных)**
    - Транзакции читают только зафиксированные данные.
    - Предотвращает грязное чтение.
    - Проблема: **неповторяемые чтения** (non-repeatable read).

3. **REPEATABLE READ (Повторяемое чтение)**
    - Данные, считанные в рамках транзакции, не изменятся до её завершения.
    - Предотвращает неповторяемые чтения.
    - Проблема: **фантомные чтения** (phantom read).

4. **SERIALIZABLE (Сериализуемый)**
    - Транзакции выполняются последовательно.
    - Защищает от всех типов проблем, но может снизить производительность.

### ACID

**ACID** - набор свойств, гарантирующих надежную работу транзакций:

1. **Atomicity (Атомарность)**
    - Транзакция выполняется как единое целое - либо все операции выполняются, либо все отменяются.

2. **Consistency (Согласованность)**
    - База данных переходит из одного согласованного состояния в другое.
    - Все бизнес-правила и ограничения сохраняются.

3. **Isolation (Изоляция)**
    - Транзакции выполняются независимо друг от друга.
    - Изменения одной транзакции не видны другим до её завершения.

4. **Durability (Долговечность)**
    - После фиксации транзакции изменения сохраняются, даже в случае сбоя системы.

### Liquibase

**Liquibase** - инструмент для управления миграциями базы данных.

**Как добавить Liquibase в проект**:
1. Подключить зависимость в pom.xml:
   ```xml
   <dependency>
       <groupId>org.liquibase</groupId>
       <artifactId>liquibase-core</artifactId>
   </dependency>
   ```

2. Настроить конфигурации в application.properties:
   ```properties
   spring.liquibase.change-log=classpath:db/changelog/db.changelog-master.xml
   ```

3. Создать файл changelog, описывающий миграции.

**Условия выполнения в Liquibase**:
Используются теги `<preConditions>` для проверки условий перед применением изменений.

```xml
<changeSet id="1" author="author">
    <preConditions onFail="MARK_RAN">
        <not>
            <tableExists tableName="users"/>
        </not>
    </preConditions>
    <createTable tableName="users">
        <!-- Определение колонок -->
    </createTable>
</changeSet>
```

Параметр **onFail** определяет действие при невыполнении условия:
- **HALT** - остановить выполнение (по умолчанию).
- **MARK_RAN** - пометить как выполненный, но не применять.
- **SKIP** - пропустить выполнение.

Типы проверок:
- **tableExists** - проверяет существование таблицы.
- **columnExists** - проверяет наличие колонки.
- **indexExists** - проверяет наличие индекса.
- **sqlCheck** - выполняет SQL-запрос для проверки.
- **dbms** - проверяет тип базы данных.
- **changeSetExecuted** - проверяет, был ли уже выполнен changeSet.

## Тестирование

### Модульное тестирование

**Модульное тестирование (Unit Testing)** - тестирование отдельных модулей или компонентов программы.

**Характеристики**:
- Фокусируется на небольших, изолированных частях кода.
- Быстрое выполнение.
- Часто используются "заглушки" для изоляции тестируемого компонента.

**Инструменты**:
- JUnit
- TestNG
- Mockito (для создания заглушек)

### Интеграционное тестирование

**Интеграционное тестирование** - проверяет взаимодействие между компонентами или модулями.

**Характеристики**:
- Тестирует взаимодействие между несколькими компонентами.
- Более медленное выполнение, чем у модульных тестов.
- Может требовать дополнительную инфраструктуру.

**Инструменты**:
- Spring Test
- JUnit с аннотацией @SpringBootTest
- Testcontainers (для тестирования с реальными базами данных и другими сервисами в Docker-контейнерах)

## Сборка и управление проектами

### Maven

**Maven** - инструмент для управления сборкой и зависимостями проекта.

**Фазы жизненного цикла Maven**:
- **compile** - компилирует исходный код.
- **test** - запускает модульные тесты.
- **package** - упаковывает скомпилированный код в формат (.jar, .war, .pom).
- **install** - устанавливает артефакт в локальный репозиторий.
- **deploy** - развёртывает артефакт в удалённый репозиторий.

**Отличие Phase и Goal**:
- **Phase (фаза)** - этап в жизненном цикле сборки Maven.
- **Goal (цель)** - конкретная задача, выполняемая в рамках фазы.

### Scope зависимостей

Maven поддерживает различные scope зависимостей:

- **compile** (по умолчанию) - доступны на всех этапах проекта.
- **test** - доступны только на этапе тестирования.
- **provided** - предполагается, что зависимость будет предоставлена JDK или контейнером во время выполнения.
- **runtime** - необходимы только во время выполнения, не требуются при компиляции.
- **system** - зависимости, находящиеся в файловой системе (не загружаются из репозитория).

### Git

**Основные команды Git**:

- **git cherry-pick** - применить изменения из одного коммита в другую ветку.
- **git stash** - сохранить изменения и перейти в другую ветку.
- **git merge** - объединить две ветки.
- **git rebase** - перенести изменения из одной ветки в другую.
- **git pull** - получить и объединить изменения из удаленного репозитория.
- **git push** - отправить изменения в удаленный репозиторий.
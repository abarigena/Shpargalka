Отлично! Давайте структурируем вашу шпаргалку и добавим новую информацию. Я постараюсь сгруппировать все по логическим разделам для удобства.

***

# Шпаргалка для собеседований по Java

## Содержание

1.  [Java Core](#java-core)
    *   [Основы и ООП](#основы-и-ооп)
    *   [Generics (Обобщения)](#generics-обобщения)
    *   [Коллекции](#коллекции)
    *   [Исключения](#исключения-1)
    *   [Stream API](#stream-api-1)
    *   [Работа с памятью и GC](#работа-с-памятью-и-gc)
    *   [Рефлексия](#рефлексия-1)
2.  [Concurrency (Многопоточность)](#concurrency-многопоточность)
3.  [Базы данных и Persistence](#базы-данных-и-persistence)
    *   [Общие концепции БД](#общие-концепции-бд)
    *   [JDBC vs ORM/JPA](#jdbc-vs-ormjpa)
    *   [JPA/Hibernate](#jpahibernate)
    *   [Миграции (Liquibase)](#миграции-liquibase)
    *   [Безопасность (SQL Injection)](#безопасность-sql-injection)
4.  [Spring Framework](#spring-framework-1)
    *   [Основы Spring и Spring Boot](#основы-spring-и-spring-boot)
    *   [Spring Core (DI, IoC, Beans)](#spring-core-di-ioc-beans)
    *   [Spring Data](#spring-data)
    *   [Spring Web](#spring-web)
    *   [Spring AOP](#spring-aop)
    *   [Транзакции в Spring](#транзакции-в-spring)
    *   [Планировщик задач](#планировщик-задач-1)
5.  [Микросервисы и Распределенные системы](#микросервисы-и-распределенные-системы)
    *   [Архитектурные стили](#архитектурные-стили)
    *   [Коммуникация](#коммуникация)
    *   [Паттерны координации](#паттерны-координации)
    *   [Распределенные транзакции](#распределенные-транзакции)
    *   [API Gateway и Балансировка](#api-gateway-и-балансировка)
    *   [Messaging (Kafka)](#messaging-kafka)
6.  [Контейнеризация и Оркестрация](#контейнеризация-и-оркестрация)
    *   [Docker](#docker)
    *   [Kubernetes](#kubernetes)
7.  [Инструменты и Сборка](#инструменты-и-сборка)
    *   [Maven](#maven-1)
    *   [Git](#git-1)
    *   [CI/CD](#cicd)
8.  [Тестирование](#тестирование-1)
9.  [Принципы проектирования](#принципы-проектирования)
10. [Сетевые протоколы и Безопасность](#сетевые-протоколы-и-безопасность)
11. [Алгоритмы и Структуры данных](#алгоритмы-и-структуры-данных)

---

## Java Core

### Основы и ООП

*   **Примитивный тип vs Ссылочный:**
    *   **Примитивы:** Хранят значение непосредственно (int, boolean, char...). Обычно на стеке. Не могут быть `null`.
    *   **Ссылочные:** Хранят адрес объекта в памяти (String, Object, любой класс). Объекты в куче. Могут быть `null`.
*   **Методы класса Object:** `equals()`, `hashCode()`, `toString()`, `getClass()`, `clone()`, `finalize()`, `wait()`, `notify()`, `notifyAll()`.
*   **Переопределение equals():** При переопределении `equals()` **обязательно** нужно переопределить `hashCode()` так, чтобы для равных по `equals()` объектов `hashCode()` возвращал одинаковое значение. Контракт `equals()`: рефлексивность, симметричность, транзитивность, консистентность, сравнение с `null` всегда `false`.
*   **Абстрактные классы:**
    *   Класс с модификатором `abstract`. Нельзя создать экземпляр (`new`).
    *   Может содержать абстрактные методы (без реализации) и обычные методы, поля (в т.ч. с состоянием), конструкторы.
    *   Используется как базовый класс для наследования. Класс может наследовать только *один* абстрактный класс.
*   **Интерфейсы:**
    *   Контракт, определяющий набор методов (до Java 8 - только абстрактных).
    *   Не может иметь полей состояния (только константы `public static final`). Нет конструкторов.
    *   Класс может реализовывать (`implements`) *множество* интерфейсов.
    *   С Java 8 могут содержать `default` (с реализацией) и `static` методы.
*   **Сравнение абстрактных классов и интерфейсов:**
    *   **Наследование:** Класс наследует 1 абстр. класс, реализует много интерфейсов.
    *   **Состояние:** Абстр. класс может иметь состояние (поля), интерфейс - нет (только константы).
    *   **Конструкторы:** Абстр. класс может иметь, интерфейс - нет.
    *   **Методы:** Абстр. класс - любые, интерфейс - `abstract`, `default`, `static` (с Java 9+ `private`).
    *   **Цель:** Абстр. класс - основа иерархии с общей реализацией/состоянием. Интерфейс - контракт поведения.
*   **Дефолтные методы в интерфейсах (Java 8+):** Позволяют добавлять новые методы в интерфейс с реализацией по умолчанию, не ломая существующие классы, реализующие этот интерфейс (обратная совместимость).

### Generics (Обобщения)

*   **Что такое:** Параметризация типов. Позволяют создавать классы, интерфейсы и методы, работающие с типами, указанными при создании/вызове.
*   **Преимущества:** Типобезопасность (ошибки на этапе компиляции), переиспользование кода, нет нужды в явном приведении типов.
*   **Стирание типов (Type Erasure):** Информация о типах-параметрах (`<T>`) удаляется компилятором и заменяется на `Object` или верхнюю границу (`<? extends Number>`). Поэтому в runtime тип `T` недоступен напрямую.
*   **Принцип PECS (Producer Extends, Consumer Super):**
    *   **Producer Extends (`? extends T`):** Если структура *поставляет* (producer) элементы типа `T` (вы читаете из нее), используйте `extends`. Безопасно читать `T`, небезопасно добавлять (кроме `null`).
    *   **Consumer Super (`? super T`):** Если структура *потребляет* (consumer) элементы типа `T` (вы пишете в нее), используйте `super`. Безопасно добавлять `T` (и подтипы), небезопасно читать (только как `Object`).

### Коллекции

*   **Иерархия:**
    *   `Iterable` (root) -> `Collection`
    *   `Collection` -> `List`, `Set`, `Queue`
    *   `List` (упорядоченный, по индексу): `ArrayList`, `LinkedList`, `Vector`, `Stack`
    *   `Set` (уникальные элементы): `HashSet`, `LinkedHashSet`, `TreeSet`
    *   `Queue` (очередь FIFO): `LinkedList`, `PriorityQueue`, `ArrayDeque`
    *   `Deque` (двусторонняя очередь): `ArrayDeque`, `LinkedList`
    *   `Map` (ключ-значение, *не* наследует `Collection`): `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable`, `ConcurrentHashMap`
*   **Map и Collection - интерфейсы?** Да, оба являются интерфейсами.
*   **Принцип работы HashMap:**
    1.  Хранит пары ключ-значение в массиве нод (бакетов).
    2.  При `put(K key, V value)`:
        *   Вычисляется `hashCode()` ключа.
        *   Хэш используется для определения индекса бакета: `index = hash & (capacity - 1)`.
        *   Если бакет пуст, создается новая нода.
        *   Если бакет не пуст (коллизия):
            *   Проверяется, есть ли ключ в существующих нодах бакета (сравнение по `hashCode()` и `equals()`).
            *   Если ключ найден, значение перезаписывается.
            *   Если ключ не найден, новая нода добавляется в конец связного списка (или вставляется в красно-черное дерево, если бакет стал слишком большим - с Java 8).
    3.  При `get(K key)`: аналогично вычисляется индекс, затем идет поиск по `equals()` внутри бакета.
    4.  **Load Factor:** Коэффициент загрузки (по умолч. 0.75). Когда `size > capacity * loadFactor`, происходит `resize` (увеличение capacity в 2 раза и перехеширование всех элементов).
    5.  **Сложность:** В среднем O(1) для `put`, `get`, `remove`. В худшем случае (все элементы в одном бакете) - O(n).

### Исключения

*   **Иерархия:** `Throwable` -> (`Error` | `Exception`)
    *   `Error`: Серьезные проблемы JVM (OutOfMemoryError, StackOverflowError). Обычно не обрабатываются.
    *   `Exception`: Ошибки, которые можно обработать.
        *   **Checked Exceptions:** Наследники `Exception` (кроме `RuntimeException`). Требуют обработки (`try-catch`) или проброса (`throws`). Примеры: `IOException`, `SQLException`. Указывают на внешние проблемы (файл не найден, сеть недоступна).
        *   **Unchecked Exceptions (Runtime Exceptions):** Наследники `RuntimeException`. Не требуют явной обработки. Обычно указывают на ошибки программирования (`NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`).
*   **Обработка Throwable:** Плохая практика, т.к. перехватывает и `Error`. Лучше ловить конкретные `Exception` или общие, но не `Throwable`.
*   **try-finally без catch:** Да, можно. Блок `finally` выполнится всегда (кроме `System.exit()` или падения JVM), гарантируя освобождение ресурсов, даже если исключение не обработано и пробрасывается дальше.
*   **Try-with-resources (Java 7+):** Автоматически закрывает ресурсы, реализующие `AutoCloseable` (например, потоки ввода/вывода, соединения). Ресурсы объявляются в скобках после `try`. `close()` вызывается неявно в конце блока (или при исключении).

```java
try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    // Работа с reader
} // reader.close() вызовется автоматически
```

### Stream API

*   **Типы операций:**
    *   **Промежуточные (Intermediate):** Ленивые, возвращают новый стрим (`filter`, `map`, `flatMap`, `sorted`, `distinct`, `peek`). Не выполняются до вызова терминальной операции.
    *   **Терминальные (Terminal):** Запускают выполнение всех промежуточных операций, завершают стрим (`forEach`, `collect`, `reduce`, `count`, `anyMatch`, `findFirst`). После них стрим использовать нельзя.
*   **Операции после терминальной:** Нет, стрим закрыт.
*   **map vs flatMap:**
    *   `map(Function<T, R> mapper)`: Преобразует каждый элемент `T` в элемент `R`. Один-в-один. `Stream<T>` -> `Stream<R>`.
    *   `flatMap(Function<T, Stream<R>> mapper)`: Преобразует каждый элемент `T` в *поток* элементов `R`, затем "сплющивает" все полученные потоки в один `Stream<R>`. Один-ко-многим. Используется для работы с вложенными структурами.
*   **Параллельный Stream (`parallelStream()` или `.parallel()`):**
    *   Выполняет операции над стримом в нескольких потоках (использует `ForkJoinPool`).
    *   Может ускорить обработку больших объемов данных на многоядерных процессорах.
    *   **Но:** Не всегда быстрее (накладные расходы на разделение/слияние). Порядок элементов не гарантируется для некоторых операций (но `forEachOrdered`, `toArray`, `collect` сохраняют порядок). Требует внимания к потокобезопасности при работе с общими изменяемыми данными.

### Работа с памятью и GC

*   **Сборщик мусора (Garbage Collector):** Автоматический процесс освобождения памяти, занятой объектами, на которые больше нет ссылок (недостижимыми из "корней" - стеков потоков, статических переменных).
*   **Принцип работы (упрощенно):**
    *   **Поколения:** Объекты создаются в Young Generation (Eden). Пережившие несколько сборок GC перемещаются в Survivor Spaces, затем в Old Generation (Tenured).
    *   **Алгоритмы:**
        *   **Mark-and-Sweep:** 1. Mark (пометка достижимых). 2. Sweep (удаление недостижимых). Минус: фрагментация.
        *   **Mark-and-Compact:** Как Mark-and-Sweep, но после Sweep сдвигает живые объекты, убирая фрагментацию.
        *   **Copying Collector (для Young Gen):** Копирует живые объекты из Eden и одного Survivor Space в другой Survivor Space. Быстро, но требует вдвое больше памяти.
    *   **Stop-the-World:** Паузы в работе приложения во время выполнения GC. Разные сборщики стараются минимизировать эти паузы.
*   **Типы сборщиков мусора:**
    *   **Serial GC:** Однопоточный. Для простых приложений с малым heap.
    *   **Parallel GC (Throughput GC):** Многопоточный для Young Gen. Увеличивает пропускную способность, но паузы могут быть длинными. Дефолтный до Java 9.
    *   **CMS (Concurrent Mark Sweep):** Работает параллельно с приложением большую часть времени, минимизируя паузы. Устарел.
    *   **G1 (Garbage-First):** Делит heap на регионы. Пытается уложиться в целевое время паузы. Дефолтный с Java 9.
    *   **ZGC, Shenandoah:** Новейшие сборщики с очень короткими паузами, работают почти полностью конкурентно.

### Рефлексия

*   **Что такое:** Механизм для интроспекции (исследования) и манипуляции классами, интерфейсами, полями и методами во время выполнения.
*   **Возможности:** Получать информацию о классе (`Class<?>`), создавать экземпляры (`newInstance()`), вызывать методы (`Method.invoke()`), получать/изменять значения полей (`Field.get/set`), даже `private`.
*   **Применение:** Фреймворки (Spring, Hibernate), сериализация, тестирование.
*   **Минусы:** Медленнее прямого вызова, нарушает инкапсуляцию, усложняет код.

---

## Concurrency (Многопоточность)

*   **Процесс vs Поток (Тред):**
    *   **Процесс:** Экземпляр выполняемой программы. Имеет свое адресное пространство памяти. Изолирован.
    *   **Поток (Thread):** Легковесный процесс внутри основного процесса. Потоки одного процесса разделяют общее адресное пространство (heap), но имеют свой стек вызовов.
*   **Поток vs Тред в Java:** В Java это синонимы (`java.lang.Thread`).
*   **Создание потока:**
    *   Наследование `Thread` и переопределение `run()`.
    *   Реализация `Runnable` и передача экземпляра в конструктор `Thread`. (Предпочтительнее).
*   **Состояния потока:**
    *   `NEW`: Создан, но не запущен (`start()` не вызван).
    *   `RUNNABLE`: Готов к выполнению или выполняется JVM.
    *   `BLOCKED`: Ждет освобождения монитора (входа в `synchronized` блок/метод).
    *   `WAITING`: Ждет события от другого потока (`object.wait()`, `thread.join()`, `LockSupport.park()`).
    *   `TIMED_WAITING`: Ждет события определенное время (`Thread.sleep()`, `object.wait(timeout)`, `thread.join(timeout)`...).
    *   `TERMINATED`: Завершил выполнение метода `run()`.
*   **Демон-потоки vs Пользовательские:**
    *   **Пользовательские:** JVM завершится только когда все они закончат работу.
    *   **Демоны (`setDaemon(true)`):** Фоновые потоки. JVM не ждет их завершения. Если все пользовательские потоки завершились, демоны принудительно останавливаются. Пример: GC.
*   **Executor Framework (`java.util.concurrent`):**
    *   Абстракция для управления выполнением задач (`Runnable`, `Callable`) в пулах потоков.
    *   **`Executor`:** Базовый интерфейс (`execute(Runnable)`).
    *   **`ExecutorService`:** Расширяет `Executor`. Методы `submit()` (возвращает `Future`), `shutdown()`, `invokeAll()`, `invokeAny()`.
    *   **`Executors`:** Фабричные методы для создания пулов (`newFixedThreadPool`, `newCachedThreadPool`, `newSingleThreadExecutor`).
    *   **`ThreadPoolExecutor`:** Гибкая реализация пула потоков.
    *   **`ScheduledExecutorService`:** Для выполнения задач по расписанию или с задержкой.
*   **`java.util.concurrent`:** Пакет с утилитами для конкурентного программирования:
    *   **Атомарные переменные:** `AtomicInteger`, `AtomicBoolean`, `AtomicReference`... (гарантируют атомарность операций без блокировок).
    *   **Блокировки:** `Lock` (интерфейс), `ReentrantLock` (гибкая замена `synchronized`), `ReadWriteLock` (раздельные блокировки для чтения/записи).
    *   **Синхронизаторы:** `Semaphore` (ограничение доступа), `CountDownLatch` (ожидание завершения N операций), `CyclicBarrier` (синхронизация потоков на "барьере"), `Exchanger` (обмен данными между двумя потоками).
    *   **Конкурентные коллекции:** `ConcurrentHashMap`, `CopyOnWriteArrayList`, `BlockingQueue` (интерфейс), `ArrayBlockingQueue`, `LinkedBlockingQueue`.
*   **`ForkJoinPool`:** Специализированный `ExecutorService` для задач, использующих рекурсивное разделение ("разделяй и властвуй"). Используется в `parallelStream()`.

---

## Базы данных и Persistence

### Общие концепции БД

*   **ACID:** Свойства транзакций:
    *   **Atomicity (Атомарность):** Или все операции транзакции выполнены, или ни одной.
    *   **Consistency (Согласованность):** Транзакция переводит БД из одного валидного состояния в другое.
    *   **Isolation (Изоляция):** Параллельные транзакции не должны мешать друг другу. Результат должен быть таким же, как при последовательном выполнении.
    *   **Durability (Долговечность):** Если транзакция успешно завершена, ее результаты сохранятся даже при сбоях.
*   **Уровни изоляции транзакций:** Определяют, насколько транзакции изолированы друг от друга.
    1.  **Read Uncommitted:** Чтение незафиксированных данных ("грязное чтение"). Самый низкий уровень.
    2.  **Read Committed:** Чтение только зафиксированных данных. Предотвращает "грязное чтение". Возможны "неповторяемое чтение" (данные изменились между чтениями в одной транзакции) и "фантомное чтение" (появились новые строки).
    3.  **Repeatable Read:** Гарантирует, что повторное чтение в рамках одной транзакции вернет те же данные. Предотвращает "неповторяемое чтение". Возможны "фантомные чтения".
    4.  **Serializable:** Полная изоляция, как при последовательном выполнении. Предотвращает все проблемы, но снижает производительность.
*   **Локи (Locks):** Механизмы для управления конкурентным доступом.
    *   **Pessimistic Locking (Пессимистическая):** Блокирует ресурс (строку, таблицу) на время транзакции, не давая другим изменять (а иногда и читать) его. Подходит при высокой вероятности конфликтов. В JPA: `LockModeType.PESSIMISTIC_READ`, `PESSIMISTIC_WRITE`.
    *   **Optimistic Locking (Оптимистическая):** Не блокирует ресурс. Перед обновлением проверяет, не изменились ли данные с момента чтения (обычно через поле версии `@Version`). Если изменились - выбрасывается исключение (`OptimisticLockException`). Подходит при низкой вероятности конфликтов.

### JDBC vs ORM/JPA

*   **ORM (Object-Relational Mapping):** Технология для связи объектной модели приложения с реляционной БД. Позволяет работать с данными БД как с обычными объектами Java.
*   **JPA (Java Persistence API):** Стандартная *спецификация* для ORM в Java. Определяет интерфейсы и аннотации.
*   **Hibernate:** Одна из самых популярных *реализаций* JPA.
*   **Преимущества ORM/JPA над JDBC:**
    *   **Абстракция от БД:** Меньше зависимость от конкретной СУБД и SQL диалекта. Легче мигрировать.
    *   **Объектно-ориентированный подход:** Работа с объектами и их связями, а не с SQL-запросами и `ResultSet`.
    *   **Автоматизация:** Генерация SQL, управление транзакциями (часто декларативное), маппинг данных.
    *   **Кеширование:** Встроенные механизмы кеширования (L1, L2) для повышения производительности.
    *   **JPQL/HQL:** Объектно-ориентированные языки запросов, более абстрактные, чем SQL.
    *   **Управление схемой:** Инструменты для генерации/обновления схемы БД (например, `hibernate.hbm2ddl.auto`).

### JPA/Hibernate

*   **Стратегии Fetching (Загрузки связей):**
    *   **`FetchType.LAZY` (Ленивая):** Связанные сущности/коллекции не загружаются из БД до первого обращения к ним. Требует активной сессии Hibernate или транзакции. *По умолчанию для коллекций (`@OneToMany`, `@ManyToMany`).*
    *   **`FetchType.EAGER` (Жадная):** Связанные сущности/коллекции загружаются сразу вместе с основной сущностью одним запросом. *По умолчанию для одиночных связей (`@ManyToOne`, `@OneToOne`).* Может приводить к проблеме N+1.
*   **Проблема N+1:** Возникает при EAGER-загрузке коллекций или при LAZY-загрузке без активной сессии/транзакции вне метода репозитория. Сначала выполняется 1 запрос для получения основной сущности (или списка сущностей), а затем N дополнительных запросов для загрузки связанных коллекций/сущностей для каждой из N основных.
*   **Решения проблемы N+1:**
    *   **JOIN FETCH:** В JPQL/HQL указать `JOIN FETCH association` для загрузки связи одним запросом.
        ```jpql
        SELECT a FROM Author a JOIN FETCH a.books WHERE a.id = :id
        ```
    *   **EntityGraph:** Определить граф сущностей, указывая, какие атрибуты/связи загружать вместе с основной. Передается как hint к запросу (`javax.persistence.fetchgraph` или `javax.persistence.loadgraph`).
    *   **@BatchSize:** Аннотация Hibernate для загрузки LAZY-коллекций пачками (уменьшает N запросов до N/batch_size).
*   **Получение данных LAZY сущностей вне транзакции:**
    *   Если сессия закрыта, будет `LazyInitializationException`.
    *   **Решения:** Использовать `JOIN FETCH` или `EntityGraph` в запросе репозитория; расширить границы транзакции (`@Transactional` на сервисном методе); вызвать `Hibernate.initialize(entity.getLazyCollection())` внутри транзакции.
*   **Cascade Types (Каскадные операции):** Определяют, как операции над родительской сущностью влияют на связанные дочерние сущности. Задаются в аннотациях связей (`@OneToMany(cascade = ...)`).
    *   `CascadeType.PERSIST`: При сохранении родителя сохраняются и новые дочерние.
    *   `CascadeType.MERGE`: При обновлении (слиянии) родителя обновляются и дочерние.
    *   `CascadeType.REMOVE`: При удалении родителя удаляются и дочерние.
    *   `CascadeType.REFRESH`: При обновлении родителя из БД обновляются и дочерние.
    *   `CascadeType.DETACH`: При отсоединении родителя от контекста отсоединяются и дочерние.
    *   `CascadeType.ALL`: Включает все вышеперечисленные.
*   **Генераторы ID (`@GeneratedValue`):**
    *   `GenerationType.AUTO`: JPA провайдер выбирает стратегию (часто `SEQUENCE` или `IDENTITY`). *Дефолт.*
    *   `GenerationType.IDENTITY`: Использует автоинкрементное поле БД (MySQL, SQL Server). ID генерируется при `INSERT`.
    *   `GenerationType.SEQUENCE`: Использует последовательность БД (Oracle, PostgreSQL). ID генерируется перед `INSERT`. Может быть эффективнее для батчинга.
    *   `GenerationType.TABLE`: Использует отдельную таблицу для генерации ID. Самый медленный, редко используется.
*   **Составной ключ (Composite Key):** Ключ, состоящий из нескольких полей. Реализуется через:
    *   `@Embeddable` класс: Создается отдельный класс для ключа, помечается `@Embeddable`, его поля - это части ключа. В основной сущности поле этого типа помечается `@EmbeddedId`.
    *   `@IdClass`: Указывается класс, содержащий те же поля, что и составной ключ в основной сущности. Поля ключа в основной сущности помечаются `@Id`.
*   **Пагинация:** Способы получения данных порциями (страницами).
    *   **Offset-based (LIMIT/OFFSET):** `SELECT ... LIMIT <size> OFFSET <page * size>`. Просто реализуется, но может быть неэффективным на больших offset (БД все равно читает и пропускает offset строк).
    *   **Keyset-based (Cursor-based):** `SELECT ... WHERE id > <last_id_on_previous_page> ORDER BY id LIMIT <size>`. Использует значение последнего элемента предыдущей страницы для получения следующей. Более эффективен, особенно с индексами, но сложнее для произвольного перехода на страницу.
    *   **JPA/Spring Data:** `Pageable` интерфейс и `Page` объект для удобной реализации пагинации (обычно offset-based).

### Миграции (Liquibase)

*   **Что такое:** Инструмент для управления версиями схемы БД. Позволяет описывать изменения схемы (создание таблиц, добавление колонок) в виде файлов (XML, YAML, SQL) и последовательно применять их к БД.
*   **Подключение (Spring Boot):** Добавить зависимость `liquibase-core`, создать мастер-файл changelog (например, `db/changelog/db.changelog-master.xml`) и указать путь в `application.properties` (`spring.liquibase.change-log=...`).
*   **ChangeSet:** Единица изменения в Liquibase. Имеет `id` и `author`.
*   **Preconditions (`<preConditions>`):** Условия для выполнения changeset.
    *   `onFail`: Что делать, если условие не выполнено (`HALT`, `MARK_RAN`, `SKIP`).
    *   `onError`: Что делать при ошибке выполнения changeset.
    *   Типы проверок: `tableExists`, `columnExists`, `sqlCheck`, `dbms`, `changeSetExecuted` и др.

### Безопасность (SQL Injection)

*   **Что такое:** Уязвимость, позволяющая атакующему внедрить произвольный SQL-код в запрос к БД через пользовательский ввод. Может привести к чтению, изменению, удалению данных, обходу аутентификации.
*   **Причина:** Конкатенация строк для формирования SQL-запроса с использованием непроверенных пользовательских данных.
*   **Защита:**
    *   **Prepared Statements (Параметризованные запросы):** Вместо конкатенации используются плейсхолдеры (`?`), а значения передаются отдельно. Драйвер БД сам безопасно экранирует данные. **Основной метод защиты.**
    *   **ORM (JPA/Hibernate):** По умолчанию используют Prepared Statements, что значительно снижает риск. Но HQL/JPQL запросы, построенные конкатенацией, все еще уязвимы!
    *   **Валидация и Санитизация ввода:** Проверка и очистка пользовательских данных перед использованием.
    *   **Принцип наименьших привилегий:** Пользователь БД, от имени которого работает приложение, должен иметь только необходимые права.

---

## Spring Framework

### Основы Spring и Spring Boot

*   **Spring Framework:** Мощный фреймворк для создания Java-приложений, основной идеей которого является Inversion of Control (IoC) и Dependency Injection (DI). Предоставляет модули для различных задач (Web, Data, Security...).
*   **Spring Boot:** Надстройка над Spring, упрощающая создание и настройку Spring-приложений. Предоставляет:
    *   **Автоконфигурация:** Автоматически настраивает бины на основе classpath и свойств.
    *   **Starter-зависимости:** Упрощают управление зависимостями (`spring-boot-starter-web`, `spring-boot-starter-data-jpa`).
    *   **Встроенные сервера:** Tomcat, Jetty, Undertow (не нужен внешний сервер приложений).
    *   **Метрики, Health Checks:** Готовые решения для мониторинга.
*   **Отличие:** Spring Boot — это способ быстро и легко *использовать* Spring Framework с минимумом конфигурации.

### Spring Core (DI, IoC, Beans)

*   **IoC (Inversion of Control):** Принцип, при котором управление жизненным циклом объектов и их зависимостей передается внешнему контейнеру (Spring IoC Container).
*   **DI (Dependency Injection):** Конкретная реализация IoC. Контейнер сам создает и внедряет зависимости (другие бины) в нужные объекты (бины).
*   **Bean:** Объект, управляемый Spring IoC контейнером.
*   **Способы внедрения зависимостей:**
    1.  **Через конструктор (Constructor Injection):** **Рекомендуемый способ.** Зависимости передаются как параметры конструктора. Делает зависимости явными и обязательными, позволяет создавать immutable бины. `@Autowired` над конструктором (не обязателен, если конструктор один).
    2.  **Через сеттер (Setter Injection):** Зависимости внедряются через вызов сеттеров. `@Autowired` над сеттером. Подходит для опциональных зависимостей.
    3.  **Через поле (Field Injection):** Зависимости внедряются напрямую в поля. `@Autowired` над полем. **Не рекомендуется** (сложнее тестировать, скрывает зависимости).
*   **Аннотации для объявления бинов:** `@Component` (базовая), `@Service` (бизнес-логика), `@Repository` (доступ к данным), `@Controller`/@`RestController` (веб-слой), `@Configuration` (конфигурационные классы).
*   **Жизненный цикл бина:**
    1.  Инстанцирование (создание объекта).
    2.  Внедрение зависимостей (DI).
    3.  Вызов методов `BeanNameAware`, `BeanFactoryAware`, `ApplicationContextAware` (если реализованы интерфейсы).
    4.  Вызов методов, аннотированных `@PostConstruct` (или `init-method` в XML/`@Bean`).
    5.  Бин готов к использованию.
    6.  При закрытии контекста: вызов методов, аннотированных `@PreDestroy` (или `destroy-method`).
*   **Scope (Область видимости) бинов:**
    *   **`singleton` (по умолчанию):** Один экземпляр на весь ApplicationContext.
    *   **`prototype`:** Новый экземпляр при каждом запросе бина (`getBean()` или инъекции). Spring не управляет полным жизненным циклом prototype бинов (не вызывает destroy-методы).
    *   **`request`:** Один экземпляр на HTTP-запрос (только в веб-приложениях).
    *   **`session`:** Один экземпляр на HTTP-сессию (только в веб-приложениях).
    *   **`application`:** Один экземпляр на `ServletContext` (только в веб-приложениях).
    *   **`websocket`:** Один экземпляр на WebSocket сессию.

### Spring Data

*   Упрощает работу с хранилищами данных (JPA, MongoDB, Redis...).
*   Основная идея - репозитории (`JpaRepository`, `CrudRepository`). Позволяет объявлять методы доступа к данным в интерфейсе, а Spring Data сам генерирует их реализацию.

### Spring Web

*   Модуль для создания веб-приложений (Spring MVC).
*   `@Controller`, `@RestController`, `@RequestMapping`, `@GetMapping`, `@PostMapping`...

### Spring AOP

*   **AOP (Aspect-Oriented Programming):** Парадигма для выделения сквозной функциональности (logging, security, transactions, caching) в отдельные модули - аспекты.
*   **Основные понятия:**
    *   **Aspect (Аспект):** Модуль, инкапсулирующий сквозную логику (`@Aspect`).
    *   **Join Point (Точка соединения):** Момент выполнения программы (вызов метода, обработка исключения).
    *   **Advice (Совет):** Действие, выполняемое аспектом в Join Point (`@Before`, `@After`, `@AfterReturning`, `@AfterThrowing`, `@Around`).
    *   **Pointcut (Срез):** Выражение, определяющее, к каким Join Points применять Advice (`@Pointcut("execution(* com.example.service.*.*(..))")`).
    *   **Target Object:** Объект, к которому применяется аспект.
    *   **Proxy:** Объект, создаваемый AOP Framework, который оборачивает Target Object для добавления логики Advice.
*   **Прокси-объекты в Spring:** Spring AOP по умолчанию использует динамические прокси:
    *   **JDK Dynamic Proxy:** Если целевой бин реализует хотя бы один интерфейс. Прокси реализует те же интерфейсы.
    *   **CGLIB Proxy:** Если целевой бин не реализует интерфейсы. Прокси наследуется от класса целевого бина. (Требует CGLIB библиотеку, включена в `spring-core`).

### Транзакции в Spring

*   **`@Transactional`:** Аннотация для декларативного управления транзакциями. Может применяться к методам или классам.
*   **Как работает:** Spring AOP создает прокси вокруг бина с `@Transactional`. Перед вызовом метода прокси начинает транзакцию, после успешного выполнения - коммитит, при исключении (по умолчанию `RuntimeException` и `Error`) - откатывает.
*   **Атрибуты `@Transactional`:**
    *   `propagation`: Определяет поведение транзакции при вызове из уже существующей транзакции (`REQUIRED`, `REQUIRES_NEW`, `SUPPORTS`, `NOT_SUPPORTED`, `MANDATORY`, `NEVER`).
    *   `isolation`: Уровень изоляции (`READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`).
    *   `readOnly`: Флаг, что транзакция только для чтения (оптимизация).
    *   `timeout`: Таймаут транзакции.
    *   `rollbackFor`/`noRollbackFor`: Явно указывает классы исключений для отката/не отката.

### Планировщик задач

*   **`@EnableScheduling`:** Включает поддержку планировщика.
*   **`@Scheduled`:** Аннотация над методом, который должен выполняться по расписанию.
    *   `fixedRate`: Запускать каждые N миллисекунд после *начала* предыдущего выполнения.
    *   `fixedDelay`: Запускать каждые N миллисекунд после *окончания* предыдущего выполнения.
    *   `cron`: Запускать по cron-выражению (`"0 0 12 * * ?"` - каждый день в 12:00).

---

## Микросервисы и Распределенные системы

### Архитектурные стили

*   **Монолит:** Все приложение - единый развертываемый модуль.
    *   ✅ Простота разработки и развертывания на начальном этапе. Единая кодовая база. Проще отладка внутри модуля. Транзакции локальные.
    *   ❌ Сложность масштабирования отдельных частей. Сильная связанность компонентов. "Большой ком грязи". Одна ошибка может обрушить все. Медленное внедрение новых технологий.
*   **Микросервисы:** Приложение разбито на набор небольших, независимо развертываемых сервисов, обычно организованных вокруг бизнес-возможностей.
    *   ✅ Независимое масштабирование, разработка и развертывание сервисов. Технологическая гетерогенность. Устойчивость к сбоям (отказ одного сервиса не валит все).
    *   ❌ Сложность распределенной системы (сетевые задержки, согласованность данных, распределенные транзакции). Накладные расходы на инфраструктуру и мониторинг. Сложность отладки между сервисами.

### Коммуникация

*   **Синхронная:** Клиент отправляет запрос и ждет ответа.
    *   **REST (HTTP):** Самый популярный. Основан на HTTP методах (GET, POST, PUT, DELETE) и ресурсах (URI). Обычно использует JSON. Stateless.
    *   **gRPC:** Фреймворк RPC от Google. Использует HTTP/2 для транспорта и Protocol Buffers для сериализации. Высокопроизводительный, поддерживает стриминг, строго типизированный контракт (IDL).
    *   **SOAP:** Протокол на основе XML. Более строгий и формальный (WSDL, XSD). Часто используется в enterprise-системах. Поддерживает WS-* стандарты (WS-Security).
*   **Асинхронная (Event-Driven):** Сервисы общаются через сообщения/события, не ожидая немедленного ответа.
    *   **Очереди сообщений / Брокеры сообщений (Kafka, RabbitMQ, ActiveMQ):** Продюсер отправляет сообщение в очередь/топик, консюмер подписывается и обрабатывает. Повышает слабую связанность и отказоустойчивость.

### Паттерны координации

*   **Оркестрация:** Центральный компонент (оркестратор) управляет потоком взаимодействия между сервисами. Он явно вызывает нужные сервисы в нужной последовательности.
    *   ✅ Проще понимать и контролировать бизнес-процесс. Логика централизована.
    *   ❌ Оркестратор становится "узким горлышком" и точкой отказа. Повышает связанность с оркестратором.
*   **Хореография:** Нет центрального координатора. Каждый сервис реагирует на события, происходящие в системе (публикуемые другими сервисами), и выполняет свою часть работы, возможно, публикуя новые события.
    *   ✅ Слабая связанность. Большая гибкость и отказоустойчивость.
    *   ❌ Сложно отслеживать и отлаживать сквозной бизнес-процесс. Логика распределена.

### Распределенные транзакции

*   Задача: обеспечить атомарность операции, затрагивающей несколько сервисов.
*   **Two-Phase Commit (2PC - Двухфазный коммит):** Протокол с координатором.
    1.  **Prepare Phase:** Координатор спрашивает всех участников "Готовы?". Участники блокируют ресурсы и отвечают "Да/Нет".
    2.  **Commit/Rollback Phase:** Если все ответили "Да", координатор посылает "Commit". Если хоть один "Нет" или таймаут - посылает "Rollback".
    *   ✅ Гарантирует атомарность.
    *   ❌ Блокирующий (участники держат блокировки до конца 2й фазы). Координатор - точка отказа. Не очень масштабируемый. Редко используется в микросервисах.
*   **Saga:** Последовательность локальных транзакций в каждом сервисе. Если шаг не удался, выполняются компенсирующие транзакции для отмены предыдущих шагов. Не обеспечивает полную атомарность (только итоговую согласованность).
    *   **Реализация:**
        *   **Хореография:** Сервисы обмениваются событиями. "Заказ создан" -> Сервис оплаты реагирует, "Оплата прошла" -> Сервис доставки реагирует...
        *   **Оркестрация:** Оркестратор вызывает сервисы и компенсирующие транзакции.

### API Gateway и Балансировка

*   **API Gateway:** Единая точка входа для внешних клиентов в систему микросервисов.
    *   **Функции:** Маршрутизация запросов, агрегация ответов, аутентификация/авторизация, Rate Limiting, кэширование, преобразование протоколов.
    *   Может выполнять базовую балансировку нагрузки между экземплярами сервисов.
*   **Load Balancer (Балансировщик нагрузки):** Распределяет входящий трафик между несколькими экземплярами серверов/сервисов.
    *   **Цели:** Повышение доступности, отказоустойчивости, производительности.
    *   **Алгоритмы:** Round Robin, Least Connections, IP Hash и др.

### Messaging (Kafka)

*   **Что такое Kafka:** Распределенная, отказоустойчивая, высокопроизводительная платформа для потоковой передачи событий/сообщений (distributed commit log).
*   **Основные компоненты:**
    *   **Broker:** Сервер Kafka, хранит данные. Кластер состоит из нескольких брокеров.
    *   **Topic (Топик):** Именованная категория/поток сообщений. Продюсеры пишут в топики, консюмеры читают из них.
    *   **Partition (Партиция):** Топик делится на партиции. Каждая партиция - это упорядоченный, неизменяемый лог сообщений. Партиции позволяют распараллелить хранение и обработку данных. Сообщения внутри одной партиции упорядочены.
    *   **Offset:** Уникальный идентификатор сообщения внутри партиции.
    *   **Producer:** Приложение, публикующее сообщения в топики Kafka.
    *   **Consumer:** Приложение, подписывающееся на топики и обрабатывающее сообщения.
    *   **Consumer Group:** Группа консюмеров, совместно читающих из топика. Каждая партиция топика назначается только одному консюмеру в рамках группы.
*   **Преимущества Kafka:** Масштабируемость, отказоустойчивость (репликация партиций), высокая пропускная способность, долгосрочное хранение данных, возможность повторной обработки.

---

## Контейнеризация и Оркестрация

### Docker

*   Платформа для разработки, доставки и запуска приложений в контейнерах. Контейнер - легковесная, изолированная среда для запуска приложения со всеми его зависимостями.
*   **Dockerfile:** Текстовый файл с инструкциями для сборки Docker-образа.
*   **Image (Образ):** Шаблон только для чтения, содержащий приложение и его среду.
*   **Container (Контейнер):** Запущенный экземпляр образа.
*   **Docker Hub:** Публичный репозиторий Docker-образов. Можно использовать и приватные репозитории (Registry).
*   **Docker Volumes:** Механизм для сохранения данных контейнера вне его файловой системы, чтобы данные не терялись при удалении/пересоздании контейнера. Позволяют шарить данные между контейнерами.
*   **Docker Compose:** Инструмент для определения и запуска многоконтейнерных Docker-приложений с помощью YAML-файла (`docker-compose.yml`). Управляет сетями, томами, связями между контейнерами.
*   **Доступ к сервису внутри контейнера:**
    *   **Проброс портов (`-p host_port:container_port`):** Делает порт контейнера доступным на хост-машине.
    *   **Docker Networks:** Контейнеры в одной сети могут общаться друг с другом по именам сервисов (как определено в Docker Compose или через `docker run --network`).

### Kubernetes (K8s)

*   Платформа для автоматизации развертывания, масштабирования и управления контейнеризированными приложениями (оркестратор контейнеров).
*   **Основные концепции:** Pod (один или несколько контейнеров), Service (сетевая абстракция для доступа к Pod'ам), Deployment (управляет репликами Pod'ов), Namespace (логическое разделение ресурсов), Ingress (управляет внешним доступом).

---

## Инструменты и Сборка

### Maven

*   Инструмент для автоматизации сборки проектов и управления зависимостями. Использует XML-файл `pom.xml`.
*   **Жизненный цикл:** Последовательность фаз (`validate`, `compile`, `test`, `package`, `verify`, `install`, `deploy`).
*   **Phase vs Goal:** Фаза - это этап жизненного цикла. Цель (goal) - конкретная задача (плагин), которая выполняется в рамках фазы (например, `compiler:compile` - цель плагина `maven-compiler-plugin`, выполняется в фазе `compile`).
*   **Scope зависимостей:** Определяет, на каких этапах сборки и в каком classpath доступна зависимость.
    *   `compile` (по умолчанию): Доступна везде (компиляция, тест, runtime). Попадает в артефакт.
    *   `provided`: Нужна для компиляции/тестирования, но ожидается, что будет предоставлена средой выполнения (JDK, контейнер сервлетов). Не попадает в артефакт.
    *   `runtime`: Не нужна для компиляции, но нужна во время выполнения. Попадает в артефакт.
    *   `test`: Нужна только для компиляции и запуска тестов. Не попадает в артефакт.
    *   `system`: Похожа на `provided`, но нужно явно указать путь к JAR файлу. Не рекомендуется.
    *   `import` (в `<dependencyManagement>`): Для импорта зависимостей из другого POM (BOM - Bill of Materials).

### Git

*   Распределенная система контроля версий.
*   **Основные команды:** `clone`, `add`, `commit`, `push`, `pull`, `fetch`, `merge`, `rebase`, `branch`, `checkout`, `status`.
*   **`git stash`:** Временно сохраняет незакоммиченные изменения (включая индексированные), чтобы очистить рабочую директорию. Позволяет переключиться на другую ветку, а потом вернуть изменения (`stash pop` или `stash apply`).
*   **`git cherry-pick <commit_hash>`:** Применяет изменения из указанного коммита в текущую ветку.
*   **`git merge <branch>`:** Сливает указанную ветку в текущую. Создает новый коммит слияния (merge commit), если истории веток разошлись.
*   **`git rebase <branch>`:** Переносит коммиты текущей ветки "поверх" последних изменений указанной ветки. Переписывает историю коммитов текущей ветки, делая ее линейной. **Не использовать для публичных веток!**
*   **`git pull`:** = `git fetch` (загружает изменения с удаленного репозитория) + `git merge` (сливает удаленную ветку в локальную).
*   **`git push`:** Отправляет локальные коммиты в удаленный репозиторий.

### CI/CD

*   **CI (Continuous Integration - Непрерывная Интеграция):** Практика частой автоматической сборки и тестирования кода после каждого коммита в основной репозиторий. Цель - раннее обнаружение ошибок интеграции.
*   **CD (Continuous Delivery - Непрерывная Поставка):** Расширение CI. Автоматически собирает, тестирует и *подготавливает* релиз к развертыванию (деплой на staging/production может быть ручным).
*   **CD (Continuous Deployment - Непрерывное Развертывание):** Расширение Continuous Delivery. Каждый успешно прошедший все тесты билд *автоматически* развертывается на production.
*   **Jenkins:** Популярный open-source сервер автоматизации для реализации CI/CD пайплайнов.
*   **Этапы CI/CD (пример):** Коммит -> Сборка (Maven/Gradle) -> Unit-тесты -> Анализ кода (SonarQube) -> Сборка артефакта (JAR/WAR/Docker image) -> Integration-тесты -> Деплой на Staging -> Ручное/Автоматическое тестирование -> Деплой на Production.

---

## Тестирование

*   **Модульное тестирование (Unit Testing):** Тестирование изолированных компонентов (методов, классов). Быстрые. Часто используются моки/стабы для изоляции зависимостей (Mockito). Инструменты: JUnit, TestNG.
*   **Интеграционное тестирование (Integration Testing):** Тестирование взаимодействия между несколькими компонентами (например, сервис + репозиторий + БД). Медленнее unit-тестов. Инструменты: Spring Test (`@SpringBootTest`), Testcontainers (для запуска БД и др. сервисов в Docker для тестов).

---

## Принципы проектирования

*   **SOLID:** Пять принципов ООП для создания гибких, поддерживаемых и расширяемых систем.
    *   **S (Single Responsibility Principle):** Класс должен иметь только одну причину для изменения (одну ответственность).
    *   **O (Open/Closed Principle):** Программные сущности (классы, модули) должны быть открыты для расширения, но закрыты для модификации. (Достигается через наследование, полиморфизм, шаблоны проектирования).
    *   **L (Liskov Substitution Principle):** Объекты в программе должны быть заменяемы экземплярами их подтипов без изменения правильности выполнения программы. (Наследник не должен ломать контракт базового класса).
    *   **I (Interface Segregation Principle):** Клиенты не должны зависеть от методов интерфейса, которые они не используют. Лучше много маленьких специфичных интерфейсов, чем один большой общий.
    *   **D (Dependency Inversion Principle):** Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. (Достигается через DI).

---

## Сетевые протоколы и Безопасность

*   **TLS (Transport Layer Security):** Криптографический протокол для обеспечения безопасной передачи данных в сети (пришел на смену SSL). Используется в HTTPS.
    *   **Принципы:**
        *   **Аутентификация:** Проверка подлинности сервера (и опционально клиента) с помощью цифровых сертификатов (X.509).
        *   **Конфиденциальность (Шифрование):** Данные шифруются с использованием симметричных ключей (AES, ChaCha20), согласованных во время TLS Handshake с помощью асимметричной криптографии (RSA, ECDH).
        *   **Целостность:** Проверка неизменности данных с помощью кодов аутентификации сообщений (HMAC).
*   **gRPC:** (См. раздел Микросервисы/Коммуникация)
*   **Rate Limiter:** Механизм ограничения частоты запросов к API или сервису от одного клиента или группы клиентов. Защищает от перегрузок, DDoS-атак (частично), злоупотреблений API.

---

## Алгоритмы и Структуры данных

*   **Временная сложность (Time Complexity):** Оценка времени выполнения алгоритма в зависимости от размера входных данных (n). Используется нотация "O-большое" (Big O).
    *   Поиск в глубину (DFS): O(V + E) (V - вершины, E - рёбра графа).
    *   Самая быстрая сортировка (в среднем): O(n log n) (QuickSort, MergeSort, HeapSort). Худший случай QuickSort - O(n^2).
    *   Вставка в HashMap: Средняя - O(1), Худшая - O(n).
    *   Поиск по ключу в HashMap: Средняя - O(1), Худшая - O(n).
    *   Вставка в LinkedList: В начало/конец - O(1), По индексу/значению - O(n).

***

Надеюсь, эта структурированная версия поможет вам лучше подготовиться! Удачи на собеседованиях!
